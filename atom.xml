<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinJz的博客</title>
  
  <subtitle>完成大于完美</subtitle>
  <link href="https://linjz.netlify.app/atom.xml" rel="self"/>
  
  <link href="https://linjz.netlify.app/"/>
  <updated>2023-11-04T09:47:14.003Z</updated>
  <id>https://linjz.netlify.app/</id>
  
  <author>
    <name>LinJz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何创建2个线程交替打印从1到100的数</title>
    <link href="https://linjz.netlify.app/2023/11/04/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA2%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0100%E7%9A%84%E6%95%B0/"/>
    <id>https://linjz.netlify.app/2023/11/04/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA2%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0100%E7%9A%84%E6%95%B0/</id>
    <published>2023-11-04T09:28:25.000Z</published>
    <updated>2023-11-04T09:47:14.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何创建2个线程交替打印从1到100的数"><a href="#如何创建2个线程交替打印从1到100的数" class="headerlink" title="如何创建2个线程交替打印从1到100的数"></a>如何创建2个线程交替打印从1到100的数</h1><p>我们可以创建两个线程，一个线程打印奇数，一个线程打印偶数，这样就是交替打印了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gdut.linjz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlternatePrint</span> &#123;</span><br><span class="line"><span class="comment">// 对象锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个类中实现两个线程交替打印数字1到100</span></span><br><span class="line">    <span class="comment">// 我们用线程池来创建线程，这是开启线程常用的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程池来创建线程，2个主线程，0个救急线程，救急线程存活时间0秒，阻塞队列长度为2，直接丢弃任务的拒绝政策</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                r-&gt;<span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;myThread&quot;</span>+c.getAndIncrement()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提交两个任务</span></span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">task1</span>());</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">task2</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">task1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line"><span class="comment">// task1打印奇数，如果当前是偶数，则等待</span></span><br><span class="line"><span class="comment">// 这里使用循环是为了防止虚假唤醒，但其实在这道题是没什么问题的，用if或者while都是一样的，因为只有两个线程，当线程1被唤醒的时候就必然是满足条件的时候，当多个线程就不一定了，被唤醒了不一定满足条件，可能还需要再等待，所以使用while，这里主要是要养成好习惯，直接用while</span></span><br><span class="line">                    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;打印&quot;</span>+num++);</span><br><span class="line">                  <span class="comment">// 释放锁之前唤醒等待的线程</span></span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">task2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line"><span class="comment">// task2打印偶数，如果当前是奇数，则等待</span></span><br><span class="line"><span class="comment">// 这里使用循环是为了防止虚假唤醒</span></span><br><span class="line">                    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;打印&quot;</span>+num++);</span><br><span class="line">                  <span class="comment">// 释放锁之前唤醒等待的线程</span></span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><p>说一下Java如何创建线程，创建线程的4种方式</p><h2 id="方式一-继承Thread类"><a href="#方式一-继承Thread类" class="headerlink" title="方式一 继承Thread类"></a>方式一 继承Thread类</h2><p>继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　 System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//创建两个线程，用start启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();  </span><br></pre></td></tr></table></figure><h2 id="方式二-实现Runnable接口"><a href="#方式二-实现Runnable接口" class="headerlink" title="方式二 实现Runnable接口"></a>方式二 实现Runnable接口</h2><p>实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target，也可以用匿名内部类的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　  System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//先创建一个Task类，然后把类传给线程类Thread，创建线程成功</span></span><br><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();  </span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);  </span><br><span class="line">thread.start(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类的方式</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>));</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h2 id="方式三-实现Callable接口"><a href="#方式三-实现Callable接口" class="headerlink" title="方式三 实现Callable接口"></a>方式三 实现Callable接口</h2><p>实现Callable接口，重写call方法，得指定返回值的类型，这种方式支持拿到线程运行结束的返回值，接着，实现Callable接口的实现类的实例对象作为FutureTask构造函数的target，这个FutureTask的泛型类型与前面设置的返回类型一致，可以通过这个FutureTask实例对象拿到线程运行结束的返回值，然后这个FutureTask实例对象作为Thread构造函数的target。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 创建MyCallable对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">      <span class="comment">// 创建FutureTask对象，把mc作为其构造函数的target</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">      <span class="comment">// 创建Thread对象，把ft作为其构造函数的target</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">      <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">      <span class="comment">// 调用ft的get方法获取线程运行结束结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里稍微插一段</p><h3 id="Runnable接口和Callable接口有什么区别？"><a href="#Runnable接口和Callable接口有什么区别？" class="headerlink" title="Runnable接口和Callable接口有什么区别？"></a>Runnable接口和Callable接口有什么区别？</h3><p>1.Runnable接口的run方法没有返回值；</p><p>2.Callable接口的call方法有返回值，是个泛型，和FutureTask配合可以用来获取执行的结果；</p><p>3.Callable接口的call方法允许抛出异常；而Runnable接口的run方法的异常只能在内部消化，不能继续上抛；（实现Runnable接口的run方法不能抛异常是因为Runnable接口的run方法本身没有抛异常，实现类实现接口，方法重写，子类只能抛出与父类相等或小的异常，而Callable接口的call方法本身有抛异常）</p><h3 id="线程的run方法和start方法有什么区别？"><a href="#线程的run方法和start方法有什么区别？" class="headerlink" title="线程的run方法和start方法有什么区别？"></a>线程的run方法和start方法有什么区别？</h3><p>start()：用来启动线程，通过该线程调用run方法执行run方法中定义的逻辑代码，start方法只能被调用一次。</p><p>run()：封装了要被线程执行的代码，可以被调用多次，idea会提示开启线程调用start方法而不是run方法</p><h2 id="方式四-创建线程池"><a href="#方式四-创建线程池" class="headerlink" title="方式四 创建线程池"></a>方式四 创建线程池</h2><p>创建线程池是在项目中创建线程使用最多的方式</p><h3 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231029221025025.png" alt="image-20231029221025025"></p><h3 id="线程池的执行原理"><a href="#线程池的执行原理" class="headerlink" title="线程池的执行原理"></a>线程池的执行原理</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231029221304768.png" alt="image-20231029221304768"></p><p>四种拒绝策略：</p><p>1.直接抛异常</p><p>2.用调用者所在线程执行任务</p><p>3.丢弃阻塞队列中最靠前的任务，执行当前任务</p><p>4.直接丢弃任务</p><h3 id="线程池常见的阻塞队列"><a href="#线程池常见的阻塞队列" class="headerlink" title="线程池常见的阻塞队列"></a>线程池常见的阻塞队列</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231030102152802.png" alt="image-20231030102152802"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231030102642183.png" alt="image-20231030102642183"></p><p>一般使用LinkedBlockingQueue，因为锁的粒度更小，并发能力更强，不过记得初始化其大小，否则就是无限大小的</p><h3 id="确定核心线程数"><a href="#确定核心线程数" class="headerlink" title="确定核心线程数"></a>确定核心线程数</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231030103511395.png" alt="image-20231030103511395"></p><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">            r-&gt;<span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;myThread&quot;</span>+c.getAndIncrement()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line">  <span class="comment">// 提交两个任务</span></span><br><span class="line">    threadPool.submit(()-&gt;System.out.println(Thread.currentThread().getName()));</span><br><span class="line">    threadPool.submit(()-&gt;System.out.println(Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231104171959189.png" alt="image-20231104171959189"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何创建2个线程交替打印从1到100的数&quot;&gt;&lt;a href=&quot;#如何创建2个线程交替打印从1到100的数&quot; class=&quot;headerlink&quot; title=&quot;如何创建2个线程交替打印从1到100的数&quot;&gt;&lt;/a&gt;如何创建2个线程交替打印从1到100的数&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="JUC" scheme="https://linjz.netlify.app/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>反转链表的n种考法</title>
    <link href="https://linjz.netlify.app/2023/10/18/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84n%E7%A7%8D%E8%80%83%E6%B3%95/"/>
    <id>https://linjz.netlify.app/2023/10/18/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84n%E7%A7%8D%E8%80%83%E6%B3%95/</id>
    <published>2023-10-18T11:54:55.000Z</published>
    <updated>2023-10-19T11:47:45.790Z</updated>
    
    <content type="html"><![CDATA[<p>反转链表我目前接触到有几种考法，写篇文章总结记录一下：</p><h2 id="反转整条链表"><a href="#反转整条链表" class="headerlink" title="反转整条链表"></a>反转整条链表</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/Snipaste_2023-10-18_20-22-41.png" alt="反转链表"></p><p>本题目有迭代和递归两种方法实现</p><h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">// 迭代的方式使用两个指针和一个辅助指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 当只有一个结点的时候，head不为null不需要反转直接返回head，当head为null的时候返回null，所以我们可以写一起，直接返回head，这样head为null返回head其实也是返回null，head不为null刚好返回head</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 接下来是递归方式，递归方式很神奇的，很奇妙</span></span><br><span class="line">        <span class="comment">// 递归先写递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 注意是return head而不是null，因为当到了最后一个结点的时候，不需要反转，此时head不是null，head.next是null，如果返回null就把最后一个结点给抛弃掉了，当head为null的时候返回null和返回head是一样的，区别就在于当head不是null的时候</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 仔细看就会知道每一层的这个last都是一样的，就是最后一个结点，只是我们需要不断传递上去而已</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转前n个结点"><a href="#反转前n个结点" class="headerlink" title="反转前n个结点"></a>反转前n个结点</h2><p>反转前n个结点其实就是在反转整条链表的基础上做一些小小的修改而已，同样有迭代和递归实现</p><h3 id="迭代实现-1"><a href="#迭代实现-1" class="headerlink" title="迭代实现"></a>迭代实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 需要先找到第n+1个结点</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n || node != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">        node = node.next;            </span><br><span class="line">&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">      <span class="comment">// 修改一下循环的条件</span></span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 把第n+1个结点及后边的结点接上</span></span><br><span class="line">      head.next = node;</span><br><span class="line">      <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">// 需要一个全局变量来接住第n+1个结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归先写递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">          node = head.next;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next, n - <span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转从left到right区间的结点"><a href="#反转从left到right区间的结点" class="headerlink" title="反转从left到right区间的结点"></a>反转从left到right区间的结点</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/Snipaste_2023-10-18_21-08-34.png" alt="反转从m到n的结点"></p><p>反转从left到right区间的结点就是在反转前n个结点的基础上再做一些修改而已</p><h3 id="修改迭代版"><a href="#修改迭代版" class="headerlink" title="修改迭代版"></a>修改迭代版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="comment">// 这道题是反转从1到n的链表的升级版，升级为反转从left到right的部分区间链表，我们只需要在反转1到n的基础上进行一些修改就可以了，修改递归版和修改迭代版都可以的，这里先修改迭代版</span></span><br><span class="line"><span class="comment">// 如果left等于1，那不就正好是我们想要的从1到n嘛，不为1怎么办，那就想办法让它等于1，也就是不断逻辑改变头结点直到left为1，我们可以递归下去不断改变头结点，不过注意，这样left和right也得不断跟着改变</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 需要先找到第n+1个结点</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n || node != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">        node = node.next;            </span><br><span class="line">&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">      <span class="comment">// 修改一下循环的条件</span></span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 把第n+1个结点及后边的结点接上</span></span><br><span class="line">      head.next = node;</span><br><span class="line">      <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改递归版"><a href="#修改递归版" class="headerlink" title="修改递归版"></a>修改递归版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录第n+1的结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">// 反转前n个结点，那么第n+1后面的结点就不能动，那么我们得找出第n+1的结点，且得给它记录一下，因为反转后的头结点需要指向第n+1的这个结点，毕竟后面一段不能给它丢了，而且我们使用的是递归的方式解决，所以要使用一个全局变量来记录</span></span><br><span class="line">        <span class="comment">// 递归先写递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">          node = head.next;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n-<span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="每k个结点反转"><a href="#每k个结点反转" class="headerlink" title="每k个结点反转"></a>每k个结点反转</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/Snipaste_2023-10-18_21-27-23.png" alt="每k个结点反转"></p><p>这道题也可以是在反转前n个结点的基础上进行一些修改就行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="comment">// 每k个反转一次，那么第一次就是前k个结点反转，接着我们可以让第k+1个结点成为第一个结点，那么不就又是前k个结点反转了吗，只要我们把反转后的拼接起来就可以了</span></span><br><span class="line">      <span class="comment">// p为每一层的第k+1个结点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">// 递归出口，不足k个的保持原样</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(p == <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> head;</span><br><span class="line">           &#125;</span><br><span class="line">           p = p.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 反转前k个结点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseKN(head,p);</span><br><span class="line">      <span class="comment">// head.next接的下一小段链表的新头结点</span></span><br><span class="line">       head.next = reverseKGroup(p,k);</span><br><span class="line">       <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseKN</span><span class="params">(ListNode head, ListNode node)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 这一步其实就没有必要了，因为head.next需要接的不是这个node，而是下一小段链表的新头结点，不是node这个旧头结点，当然写着也不影响，毕竟后面会接上新的头结点的，只是没有必要，但是请注意可以这么做的前提是reverseKGroup这个方法保存了node这个结点，至少得知道怎么找到node这个结点</span></span><br><span class="line">      <span class="comment">//  head.next = node;</span></span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="每2个结点反转"><a href="#每2个结点反转" class="headerlink" title="每2个结点反转"></a>每2个结点反转</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/1.png" alt="每2个结点反转"></p><p>这道题，由于我先做的每k个结点反转，所以我一开始是根据每k个结点反转修改的，但是后面越做发现不用这么麻烦的，但是我这里还是把两种方法都写一下吧</p><h3 id="由每k个结点变形"><a href="#由每k个结点变形" class="headerlink" title="由每k个结点变形"></a>由每k个结点变形</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="comment">// 这道题其实就是之前做过的每k个结点进行反转，不过就是这里k固定为2就是了，所以把之前那道题目稍微改一下就行了，一样的，因为那道题目后面如果不满足k个结点就不管，而这里不满足2也就是只剩一个结点也是不做任何操作所以刚好</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseN(head,node);</span><br><span class="line">        head.next = swapPairs(node);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, ListNode node)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 这句可以不要了，和上面同理，同样的，得记住可以这么做的前提是调用这个方法的方法保存了node这个结点，至少可以找到这个结点，否则这里没了这一句，又没有保存node结点，就会把后面的链表给丢失了</span></span><br><span class="line">       <span class="comment">// head.next = node;</span></span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNext</span> <span class="operator">=</span> swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNext;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/</a></p><p><a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/ru-he-k-ge-d591d/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/ru-he-k-ge-d591d/</a></p><p><a href="https://www.programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">https://www.programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;反转链表我目前接触到有几种考法，写篇文章总结记录一下：&lt;/p&gt;
&lt;h2 id=&quot;反转整条链表&quot;&gt;&lt;a href=&quot;#反转整条链表&quot; class=&quot;headerlink&quot; title=&quot;反转整条链表&quot;&gt;&lt;/a&gt;反转整条链表&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://l</summary>
      
    
    
    
    
    <category term="算法" scheme="https://linjz.netlify.app/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>相交链表问题</title>
    <link href="https://linjz.netlify.app/2023/10/13/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://linjz.netlify.app/2023/10/13/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-13T13:07:21.000Z</published>
    <updated>2023-10-18T11:55:40.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h2><p>力扣第 160 题【相交链表】函数头如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span>;</span><br></pre></td></tr></table></figure><p>给你输入两个链表的头结点 <code>headA</code> 和 <code>headB</code>，这两个链表可能存在相交。</p><p>如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。</p><p>比如题目给我们举的例子，如果输入的两个链表如下图：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/4.png" alt="相交链表"></p><p>那么我们的算法应该返回 <code>c1</code> 这个节点。</p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><p>仅用内存为0（1），说明不可以使用外部存储，比如使用set先将A链表的节点存储起来，再用B的结点去判断的方法，只能想其他方法了，这里有三个方法可以试一下</p><hr><h3 id="第一种-逻辑拼接"><a href="#第一种-逻辑拼接" class="headerlink" title="第一种 逻辑拼接"></a>第一种 逻辑拼接</h3><p>第一种是比较奇妙的，反正我一开始是没看懂，但当我看明白的时候就豁然开朗，nice，真的很妙，逻辑拼接，让指针p1遍历A链表，遍历完接着遍历B链表，让指针p2遍历B链表，走完接着遍历A链表，这样到最后，p1和p2会在第一个相交结点相遇，为什么呢，就上边图的示例来看，c1，c2是公共的部分，p1会先走a1，a2然后走公共部分，p2会先走b1，b2，b3然后走公共部分，接着p1走B链表的部分，就是b1，b2，b3然后到c1，p2走A链表的部分，就是a1，a2，然后c1，注意看，这个时候，p1是走了A的a1，a2，B的b1，b2，b3和一次公共部分c1，c2，而p2也是走了A的a1，a2，B的b1，b2，b3和一次公共部分c1，c2，两者是同时出发的且每次都只走一步的，，那么他们下一步就是共同到达公共部分的第一个结点，也就是我们想要的那个结点,如果AB链表没有交点的话，那么就是共同走到null结点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">// p1走完A开始走B</span></span><br><span class="line">                p1 = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p2 == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">// p2走完B开始走A</span></span><br><span class="line">                p2 = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="第二种-调整起点使得到达结尾步数一致"><a href="#第二种-调整起点使得到达结尾步数一致" class="headerlink" title="第二种 调整起点使得到达结尾步数一致"></a>第二种 调整起点使得到达结尾步数一致</h3><p>接下来我们来看看方法二，方法二就好理解一些了，比方法一好很多，方法二是我们先算出AB各自的长度，我们的目的是让p1和p2同时走到一个结点上，由于AB链表的长度不一定相同，所以从各自头结点开始走的话，不一定能同时走到结尾，如果我们可以保证他们每一次都同时走到结尾那就可以判断了，因为这个链表相交，这是一个单链表，不是二叉树什么的，就是说一个结点只能指向另一个结点，不能同时指向多个结点，而一个结点却可以被多个结点同时指向，所以当两个链表有交点的时候，其后半段就是完全一样的，所以如果p1和p2能够同时到达结尾的话必然会同时在第一个交点相遇，如果没有那么也就是同时走到null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// 先算AB的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> getLength(headA);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> getLength(headB);</span><br><span class="line">    <span class="comment">// 算出长度后，比较一下哪一个长，长的那个对应的p结点就需要先走几步，使得两个p结点到达结尾的步数一致</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">        <span class="comment">// A链表长，那p1得先走lengthA-lengthB步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthA - lengthB; i++)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lengthA &lt; lengthB)&#123;</span><br><span class="line">        <span class="comment">// B链表长，那p2得先走lengthB-lengthA步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthB - lengthA; i++)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得先判断，可能补完步数就正好是相交点</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 获取链表的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next)&#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="第三种-物理连接成环"><a href="#第三种-物理连接成环" class="headerlink" title="第三种 物理连接成环"></a>第三种 物理连接成环</h3><p>第三种方法就非常有意思了，我们可以把A的尾结点连接B的结点，第一种方法是逻辑连接，我们第三种方法就是物理连接，不过得注意我们最后得还原成原样，题目也有这句话，在返回结果后，两个链表仍保持原有的结构。那么，这样的物理连接有什么用呢，我们可以想象，如果AB相交的话，那么这样连接就会形成一个环，且环的起点就是我们要找的相交点，那么这个问题就转变成了求是否存在环且求环的起点，注意这里其实还隐藏了一个问题，就是求A链表的倒数第一个结点，有点意思吧，这个简单的问题给我变成了三个问题，是否存在环，求环的起点，求倒数第n个结点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line"><span class="comment">// 先要求A的倒数第1个结点，找到那个结点才可以与B连接，如何求呢，双指针解决，先让一个指针从头结点出发走cnt步，接着再让一个指针从头结点与这个指针同时原地出发，等第一个指针走到表尾的时候，第二个指针就走到了倒数第cnt个，这是什么原理呢，假设表长尾l，第一个指针先走了cnt步，也就是停下的地方距离表尾null还有l-cnt步，所以等到第一个指针走到表尾null的时候，第二个指针就走了l-cnt步，由于是从表头1的位置开始走的，第二个指针停下的位置是l-cnt+1，要算上头结点的位置，这个l-cnt+1就是倒数第cnt的位置，为什么呢，可以这么看，总长度是l，然后从后面开始数cnt个，所以得减去cnt，接着起点是1，是从1开始算起的，所以l-cnt+1就是倒数第cnt的位置</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headA;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// p1停下来的时候，p2就是我们要找的A的尾结点</span></span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接着就是拼接AB链表</span></span><br><span class="line">        p2.next = headB;</span><br><span class="line">        <span class="comment">// 拼接好后我们就要判断是否有环以及求环的起点了，用快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明没有环，那就还原AB链表然后返回null</span></span><br><span class="line">            p2.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 存在环，那么如何找环起点呢，假设快慢指针第一次相遇的时候，slow走了k步，fast走了2k步，多出来的这k步就是绕环走的，且是环长度的整数倍，再假设从相遇点到环的起点有m步，那么从起点到环的起点就有k-m步，而巧的是从相遇点到环的起点也是k-m步，为什么呢，因为k是环长度的整数倍，而相遇点到环的起点有m步，那么从相遇点走k步会回到相遇点，那么我们不走完k步，我们留m步不走，就是k-m步，这样到达的点就会离相遇点有m步，这也就是环的起点，因为环的起点离相遇点就是m步，而我们又是在一个环中单向行驶的，所以这一路上走到的离相遇点有m步的点就是环起点</span></span><br><span class="line">        slow = headA;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上三种方法都没有循环套循环，时间复杂度都是O(n)，也没有使用数组集合等，空间复杂度是O(1)。</p><p>参考：<a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两个链表是否相交&quot;&gt;&lt;a href=&quot;#两个链表是否相交&quot; class=&quot;headerlink&quot; title=&quot;两个链表是否相交&quot;&gt;&lt;/a&gt;两个链表是否相交&lt;/h2&gt;&lt;p&gt;力扣第 160 题【相交链表】函数头如下：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    
    <category term="算法" scheme="https://linjz.netlify.app/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue什么时候是大顶堆，什么时候是小顶堆</title>
    <link href="https://linjz.netlify.app/2023/10/12/PriorityQueue%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%A4%A7%E9%A1%B6%E5%A0%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%B0%8F%E9%A1%B6%E5%A0%86/"/>
    <id>https://linjz.netlify.app/2023/10/12/PriorityQueue%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%A4%A7%E9%A1%B6%E5%A0%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%B0%8F%E9%A1%B6%E5%A0%86/</id>
    <published>2023-10-12T12:22:10.000Z</published>
    <updated>2023-10-16T12:52:01.579Z</updated>
    
    <content type="html"><![CDATA[<p>在解lecode第23题：合并K个升序链表的时候，需要用到PriorityQueue小顶堆，每次从堆中取出最小的节点然后依次组成我们想要的链表，题解是用了Java库的中的优先级队列PriorityQueue</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(lists.length,(a,b)-&gt;(a.val - b.val));</span><br></pre></td></tr></table></figure><p>其中，这里的(a,b)-&gt;(a.val - b.val)是lambda表达式，实际上是int compare (Integer a, Integer b) { return a.val - b.val;  }</p><p>(a,b)-&gt;(a.val - b.val)到底是小顶堆还是大顶堆，怎么看呢，为什么a.val - b.val是小顶堆而b.val - a.val是大顶堆呢？</p><p><strong>由于源码中新入队元素x是在第1个参数a的位置，因此最大&#x2F;最小优先队列主要根据第1个参数的大小关系来判断</strong>。 (主要还是在于控制compare这个方法来控制大小顶堆)</p><ul><li><p>对于最小堆，当x&lt;e时，要想让x上升，即compare (x, e) &lt; 0，那就得让int compare (Integer x, Integer e) { return x &lt; e ? -1 : 1;  }</p></li><li><p>对于最大堆，当x&gt;e时，要想让x上升，即compare (x, e) &lt; 0，那就得让int compare (Integer x, Integer e) { return x &gt; e ? -1 : 1;  }</p></li></ul><p>至于为什么要让其返回负数呢？</p><p>源码是这么设计的</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/1280X1280.PNG" alt="PriorityQueue大小堆决定源码"></p><p>所以，在这里，(a,b)-&gt;(a.val - b.val)，也就是int compare (Integer a, Integer b) { return a.val - b.val;  }，a.val &lt; b.val的时候，compare (x, e) &lt; 0，a小且a上升，是小顶堆。</p><p>反之，(a,b)-&gt;(b.val - a.val)，也就是int compare (Integer a, Integer b) { return b.val - a.val;  }，a.val &gt; b.val的时候，compare (x, e) &lt; 0，a大且a上升，是大顶堆。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在解lecode第23题：合并K个升序链表的时候，需要用到PriorityQueue小顶堆，每次从堆中取出最小的节点然后依次组成我们想要的链表，题解是用了Java库的中的优先级队列PriorityQueue&lt;/p&gt;
&lt;figure class=&quot;highlight java</summary>
      
    
    
    
    
    <category term="PriorityQueue" scheme="https://linjz.netlify.app/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象基础知识回顾</title>
    <link href="https://linjz.netlify.app/2023/10/11/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <id>https://linjz.netlify.app/2023/10/11/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</id>
    <published>2023-10-11T11:07:51.000Z</published>
    <updated>2023-11-16T11:35:05.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>下面是一个求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案。</p><p><strong>面向过程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义圆的半径</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算圆的面积和周长</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> Math.PI * radius * radius;</span><br><span class="line">        <span class="type">double</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出圆的面积和周长</span></span><br><span class="line">        System.out.println(<span class="string">&quot;圆的面积为：&quot;</span> + area);</span><br><span class="line">        System.out.println(<span class="string">&quot;圆的周长为：&quot;</span> + perimeter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面向对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="comment">// 定义圆的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算圆的面积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算圆的周长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPerimeter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个半径为3的圆</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出圆的面积和周长</span></span><br><span class="line">        System.out.println(<span class="string">&quot;圆的面积为：&quot;</span> + circle.getArea());</span><br><span class="line">        System.out.println(<span class="string">&quot;圆的周长为：&quot;</span> + circle.getPerimeter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，面向对象开发的程序一般更易维护、易复用、易扩展。</p><hr><h3 id="对象实体与对象引用"><a href="#对象实体与对象引用" class="headerlink" title="对象实体与对象引用"></a>对象实体与对象引用</h3><p>new 创建对象实例（对象实例在 内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><hr><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率.</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。（拥有父类没有的属性和方法）</li><li>子类可以用自己的方式实现父类的方法。(方法重写)</li></ol><hr><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><hr><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是<strong>所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><hr><h3 id="深拷贝，浅拷贝和引用拷贝"><a href="#深拷贝，浅拷贝和引用拷贝" class="headerlink" title="深拷贝，浅拷贝和引用拷贝"></a>深拷贝，浅拷贝和引用拷贝</h3><p>关于深拷贝和浅拷贝区别：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。(这是因为没有调用Address的clone方法，Person的clone方法只是调用super.clone()而已，所以Address还是同一个，故深拷贝就要连Address也一起复制，而不是共用同一个)</p><hr><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><hr><h4 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h4><p>引用拷贝就是两个不同的引用指向同一个对象。</p><hr><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><h4 id="为什么有hashCode"><a href="#为什么有hashCode" class="headerlink" title="为什么有hashCode"></a>为什么有hashCode</h4><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p><p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了<code>equals</code> 的次数，相应就大大提高了执行速度。</p><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><hr><h4 id="那为什么-JDK-还要同时提供hashCode-和-equals-这两个方法呢？"><a href="#那为什么-JDK-还要同时提供hashCode-和-equals-这两个方法呢？" class="headerlink" title="那为什么 JDK 还要同时提供hashCode() 和 equals()这两个方法呢？"></a>那为什么 JDK 还要同时提供<code>hashCode()</code> 和 <code>equals()</code>这两个方法呢？</h4><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h4 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a>那为什么不只提供 <code>hashCode()</code> 方法呢？</h4><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><hr><h4 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</h4><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><hr><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong>：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p>就会出现一个值有多个位置的情况</p><p><strong>总结</strong>：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>但两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><hr><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><p><strong>可变性</strong></p><p><code>String</code> 是不可变的（后面会详细分析原因）。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><hr><h4 id="String为什么是不可变的？"><a href="#String为什么是不可变的？" class="headerlink" title="String为什么是不可变的？"></a>String为什么是不可变的？</h4><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<del>所以<code>String</code> 对象是不可变的。</del></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况，只是不能再指向其他对象而已，并不是不能修改）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p>在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p><hr><h4 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h4><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。(其他情况下的“+”是值相加，而String的“+”并不是地址值相加)</p><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。这个改进是 JDK9 的 <a href="https://openjdk.org/jeps/280">JEP 280open in new window</a> 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。</p><hr><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象?"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象?</h4><p>会创建 1 或 2 个字符串对象。</p><p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</p><p>示例代码（JDK 1.8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><p>示例代码（JDK 1.8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象“abc”的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="String的intern方法有什么用？"><a href="#String的intern方法有什么用？" class="headerlink" title="String的intern方法有什么用？"></a>String的intern方法有什么用？</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><p>示例代码（JDK 1.8） :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>s3指向的是堆中新new出来的“Java”，并不是s1时在堆中创建的“Java”，但是注意常量池中保存的是指向s1时在堆中创建的“Java”的引用，即s1，所以s3.intern()返回的是常量池中“Java”对应的引用s1。</p><hr><h4 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h4><p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。所以这里比较的是地址值。</p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure><p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p><p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>被<code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h4><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><hr><h4 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。（必须处理否则无法通过编译）</p><p>常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><hr><h4 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h4><ul><li><p><code>String getMessage()</code>: 返回异常发生时的简要描述</p></li><li><p><code>String toString()</code>: 返回异常发生时的详细信息</p></li><li><p><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</p></li><li><p><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</p></li></ul><hr><h4 id="try-catch-finally-如何使用"><a href="#try-catch-finally-如何使用" class="headerlink" title="try-catch-finally 如何使用?"></a>try-catch-finally 如何使用?</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h4><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><hr><h4 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h4><ol><li><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p></li><li><p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行（catch和finally块不需要用到资源）</p></li></ol><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h4><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li><li>……</li></ul><hr><p>参考：</p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html">https://javaguide.cn/java/basis/java-basic-questions-02.html</a></p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html">https://javaguide.cn/java/basis/java-basic-questions-03.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;h3 id=&quot;面向对象与面向过程&quot;&gt;&lt;a href=&quot;#面向对象与面向过程&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Java面向对象" scheme="https://linjz.netlify.app/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础概念与常识</title>
    <link href="https://linjz.netlify.app/2023/10/10/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
    <id>https://linjz.netlify.app/2023/10/10/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</id>
    <published>2023-10-10T13:55:31.000Z</published>
    <updated>2023-10-16T12:38:13.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础概念与常识"><a href="#Java基础概念与常识" class="headerlink" title="Java基础概念与常识"></a>Java基础概念与常识</h2><h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><ol><li><p>简单易学</p></li><li><p>面向对象（封装，继承，多态）</p></li><li><p>平台无关性（JVM实现平台无关性）</p></li><li><p>支持多线程（C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）</p><p>Java实现多线程的方式有：</p></li></ol><ul><li><p>继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　 System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//创建两个线程，用start启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();  </span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target，可以用匿名内部类的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">OtherClass</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　  System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//先创建一个MyThread类，然后把类传给线程类Thread，创建线程成功</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);  </span><br><span class="line">thread.start();  </span><br></pre></td></tr></table></figure></li><li><p>通过线程池创建线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;通过线程池方式创建的线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;POOL_NUM; i++) &#123;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">// Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line">executorService.execute(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>异常处理和自动内存管理</li><li>编译与解释并存（先编译成.class文件再交给各对应操作系统的JVM解释执行）</li></ol><p>⚠️注意：实际上，跨平台已经不是Java最大的卖点了，目前市面上虚拟化技术已经非常成熟了，比如Docker就很容易实现跨平台，Java强大的生态才是真的值得关注的！</p><hr><h3 id="JDK-vs-JRE-vs-JVM"><a href="#JDK-vs-JRE-vs-JVM" class="headerlink" title="JDK vs JRE vs JVM"></a>JDK vs JRE vs JVM</h3><p>这三者是不断包含的关系，JDK包含JRE，JRE包含JVM。</p><p>JDK包括JRE和Java，Javadoc等工具</p><p>JRE包括JVM，Java基础类库</p><p>⚠️注意：如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><hr><h3 id="JIT和AOT"><a href="#JIT和AOT" class="headerlink" title="JIT和AOT"></a>JIT和AOT</h3><p>有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><h4 id="既然AOT-这么多优点，那为什么不全部使用这种编译方式呢？"><a href="#既然AOT-这么多优点，那为什么不全部使用这种编译方式呢？" class="headerlink" title="既然AOT 这么多优点，那为什么不全部使用这种编译方式呢？"></a>既然AOT 这么多优点，那为什么不全部使用这种编译方式呢？</h4><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。（但也不是全部都是JIT来做，JIT只是一些热点代码，其余的还是一句一句解释执行的，所以是编译与解释并存）</p><hr><h3 id="Java与C"><a href="#Java与C" class="headerlink" title="Java与C++"></a>Java与C++</h3><ul><li><p>Java 不提供指针来直接访问内存，程序内存更加安全</p></li><li><p>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</p></li><li><p>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</p></li><li><p>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p></li></ul><hr><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java有8种基本数据类型：</p><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p><strong>注意：</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><hr><h4 id="基本类型与包装类型"><a href="#基本类型与包装类型" class="headerlink" title="基本类型与包装类型"></a>基本类型与包装类型</h4><ul><li><p>用途：基本类型一般用于常量和局部变量，包装类型除了常量，局部变量，还有方法参数，对象属性，以及泛型。</p></li><li><p>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。（未被static修饰说明属于对象，对象是在堆中的，如果被static修饰说明属于类，存放在栈）一般成员变量应使用基本数据类型对应的包装类型；</p><p>包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。（这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存）</p></li><li><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p></li><li><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p></li><li><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p></li></ul><hr><h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>⚠️注意：所有的包装类对象之间值的比较，全部应该使用equals方法来比较，这是因为对于Integer var &#x3D; ? 在-128到127之间的赋值，Integer对象是在IntegerCache.cache产生的，会复用已有的对象，这个区间内的Integer值可以直接使用&#x3D;&#x3D;进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有的对象，这是一个大坑，推荐使用equals方法进行判断。</p><hr><h4 id="自动装箱与拆箱的原理"><a href="#自动装箱与拆箱的原理" class="headerlink" title="自动装箱与拆箱的原理"></a>自动装箱与拆箱的原理</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型</li></ul><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h4><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h4><ol><li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p></li><li><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p></li></ol><hr><h4 id="静态方法和实例方法"><a href="#静态方法和实例方法" class="headerlink" title="静态方法和实例方法"></a>静态方法和实例方法</h4><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式<code>对象.方法名</code> 的方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><hr><h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p><strong>重载</strong>：同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。（发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，仅仅只是返回值不同不算是重载，必须是参数不同，但重载的方法返回值和访问修饰符可以不同）</p><p><strong>重写</strong>：子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p><p><strong>方法的重写要遵循“两同两小一大”</strong></p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><hr><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：<a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础概念与常识&quot;&gt;&lt;a href=&quot;#Java基础概念与常识&quot; class=&quot;headerlink&quot; title=&quot;Java基础概念与常识&quot;&gt;&lt;/a&gt;Java基础概念与常识&lt;/h2&gt;&lt;h3 id=&quot;Java语言的特点&quot;&gt;&lt;a href=&quot;#Java语言的特</summary>
      
    
    
    
    
    <category term="Java SE" scheme="https://linjz.netlify.app/tags/Java-SE/"/>
    
  </entry>
  
</feed>
