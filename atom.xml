<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinJz的博客</title>
  
  <subtitle>完成大于完美</subtitle>
  <link href="https://se-linjz.github.io/atom.xml" rel="self"/>
  
  <link href="https://se-linjz.github.io/"/>
  <updated>2023-10-10T13:56:46.470Z</updated>
  <id>https://se-linjz.github.io/</id>
  
  <author>
    <name>LinJz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础概念与常识</title>
    <link href="https://se-linjz.github.io/2023/10/10/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
    <id>https://se-linjz.github.io/2023/10/10/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</id>
    <published>2023-10-10T13:55:31.000Z</published>
    <updated>2023-10-10T13:56:46.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础概念与常识"><a href="#Java基础概念与常识" class="headerlink" title="Java基础概念与常识"></a>Java基础概念与常识</h2><h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><ol><li><p>简单易学</p></li><li><p>面向对象（封装，继承，多态）</p></li><li><p>平台无关性（JVM实现平台无关性）</p></li><li><p>支持多线程（C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）</p><p>Java实现多线程的方式有：</p></li></ol><ul><li><p>继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　 System.out.println(<span class="string">&quot;线程的run（）方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//创建两个线程，用start启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();  </span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target，可以用匿名内部类的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">OtherClass</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　  System.out.println(<span class="string">&quot;线程的run（）方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//先创建一个MyThread类，然后把类传给线程类Thread，创建线程成功</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);  </span><br><span class="line">thread.start();  </span><br></pre></td></tr></table></figure></li><li><p>通过线程池创建线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;通过线程池方式创建的线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;POOL_NUM; i++) &#123;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">// Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line">executorService.execute(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>异常处理和自动内存管理</li><li>编译与解释并存（先编译成.class文件再交给各对应操作系统的JVM解释执行）</li></ol><p>⚠️注意：实际上，跨平台已经不是Java最大的卖点了，目前市面上虚拟化技术已经非常成熟了，比如Docker就很容易实现跨平台，Java强大的生态才是真的值得关注的！</p><hr><h3 id="JDK-vs-JRE-vs-JVM"><a href="#JDK-vs-JRE-vs-JVM" class="headerlink" title="JDK vs JRE vs JVM"></a>JDK vs JRE vs JVM</h3><p>这三者是不断包含的关系，JDK包含JRE，JRE包含JVM。</p><p>JDK包括JRE和Java，Javadoc等工具</p><p>JRE包括JVM，Java基础类库</p><p>⚠️注意：如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><hr><h3 id="JIT和AOT"><a href="#JIT和AOT" class="headerlink" title="JIT和AOT"></a>JIT和AOT</h3><p>有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><h4 id="既然AOT-这么多优点，那为什么不全部使用这种编译方式呢？"><a href="#既然AOT-这么多优点，那为什么不全部使用这种编译方式呢？" class="headerlink" title="既然AOT 这么多优点，那为什么不全部使用这种编译方式呢？"></a>既然AOT 这么多优点，那为什么不全部使用这种编译方式呢？</h4><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。（但也不是全部都是JIT来做，JIT只是一些热点代码，其余的还是一句一句解释执行的，所以是编译与解释并存）</p><hr><h3 id="Java与C"><a href="#Java与C" class="headerlink" title="Java与C++"></a>Java与C++</h3><ul><li><p>Java 不提供指针来直接访问内存，程序内存更加安全</p></li><li><p>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</p></li><li><p>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</p></li><li><p>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p></li></ul><hr><p>参考：<a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础概念与常识&quot;&gt;&lt;a href=&quot;#Java基础概念与常识&quot; class=&quot;headerlink&quot; title=&quot;Java基础概念与常识&quot;&gt;&lt;/a&gt;Java基础概念与常识&lt;/h2&gt;&lt;h3 id=&quot;Java语言的特点&quot;&gt;&lt;a href=&quot;#Java语言的特</summary>
      
    
    
    
    
    <category term="Java SE" scheme="https://se-linjz.github.io/tags/Java-SE/"/>
    
  </entry>
  
</feed>
