<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinJz的博客</title>
  
  <subtitle>完成大于完美</subtitle>
  <link href="https://linjz.netlify.app/atom.xml" rel="self"/>
  
  <link href="https://linjz.netlify.app/"/>
  <updated>2024-05-19T04:39:17.306Z</updated>
  <id>https://linjz.netlify.app/</id>
  
  <author>
    <name>LinJz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统-网络系统</title>
    <link href="https://linjz.netlify.app/2024/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://linjz.netlify.app/2024/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-03-24T03:58:57.000Z</published>
    <updated>2024-05-19T04:39:17.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。</p><h1 id="IO多路复用？select，poll，epoll的区别？"><a href="#IO多路复用？select，poll，epoll的区别？" class="headerlink" title="IO多路复用？select，poll，epoll的区别？"></a>IO多路复用？select，poll，epoll的区别？</h1><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用是一种高效的IO处理方式，它允许单个进程或线程同时监视多个文件描述符，如网络连接或文件句柄。当这些描述符中的任何一个就绪时，比如有数据可读或可写，多路复用机制就能够通知应用程序进行相应的读写操作。这种机制的核心优势在于，它可以在不增加额外线程或进程的情况下，处理大量的并发连接，从而显著地提高系统的并发性和响应能力。</p><p>常见的IO多路复用技术包括select，poll，epoll等。这些技术各有特点，但核心思想都是通过一个线程来管理多个连接，减少系统资源的消耗，并提高程序运行的效率。</p><h2 id="select，poll，epoll的区别"><a href="#select，poll，epoll的区别" class="headerlink" title="select，poll，epoll的区别"></a>select，poll，epoll的区别</h2><p>select是最早的一种I&#x2F;O多路复用技术。它使用一个fd_set数据结构来表示所有被监视的文件描述符。然而，select有几个明显的缺点。首先，它监视的文件描述符数量有限，默认上限是1024。其次，每次调用select时，都需要将fd_set从用户态拷贝到内核态，并且在内核中需要遍历所有被监视的文件描述符来检查是否有就绪的，这个开销在文件描述符数量很多时会变得非常大。最后，select返回后，还需要再次遍历fd_set来找出哪些文件描述符是就绪的，这进一步增加了处理开销。</p><p>poll则是select的一种改进方案。它使用pollfd结构来表示被监视的文件描述符及其事件。与select相比，poll没有文件描述符数量的限制，因为它基于链表来存储。然而，poll仍然需要在每次调用时从用户态拷贝所有的pollfd结构到内核态，并在内核态中遍历检查每个文件描述符的状态，然后返回的时候，也是需要遍历pollfd来找哪些是就绪的，因此，当文件描述符数量很多时，poll性能会下降。</p><p>epoll则是Linux特有的I&#x2F;O多路复用技术，它在很多方面都优于select和poll。首先，epoll只在初始时完成一次文件描述符的注册，避免了每次调用时的拷贝开销。其次，epoll采用回调函数的方式，只有当一个或多个文件描述符就绪时，才会调用回调函数并通知用户空间，这使得epoll在处理大量文件描述符时仍然保持高效。最后，epoll返回时已经明确指出了哪些文件描述符时就绪的，因此无需再像select和poll那样进行额外的遍历操作。</p><h2 id="epoll的具体实现？epoll的事件触发有哪几种方式？"><a href="#epoll的具体实现？epoll的事件触发有哪几种方式？" class="headerlink" title="epoll的具体实现？epoll的事件触发有哪几种方式？"></a>epoll的具体实现？epoll的事件触发有哪几种方式？</h2><h3 id="epoll的实现？"><a href="#epoll的实现？" class="headerlink" title="epoll的实现？"></a>epoll的实现？</h3><p>epoll通过一种高效的数据结构来管理大量的文件描述符，这个数据结构是红黑树。红黑树是一种自平衡的二叉搜索树，它在添加，删除和搜索操作中都能保持相对平衡，从而保证这些操作的时间复杂度接近O（lgn）。在epoll中，每个文件描述符作为红黑树的一个节点被存储，这样可以高效地管理和检索大量的文件描述符。</p><p>epoll的另一个关键特性是其事件驱动的回调机制。当注册的文件描述符上发生特定事件（如数据可读，可写或异常）时，内核不会立即通知应用程序，而是将这些事件添加到就绪链表中。这个链表包含了所有已经就绪（即有事件发生）的文件描述符。当应用程序调用epoll_wait()函数时，内核会检查就绪链表，并返回其中已经就绪的文件描述符列表，从而实现了事件驱动的回调通知。</p><p>此外，epoll还使用了内存映射技术来减少不必要的内存拷贝。通过将用户空间和内核空间的部分内存映射到同一个物理内存页，epoll能够在内核空间和用户空间之间高效地传递事件信息，进一步降低了系统调用的开销。</p><p>总的来说，epoll通过结合红黑树，就绪链表和内存映射技术，实现了一种高效，可扩展且低开销的I&#x2F;O多路复用机制，特别适用于需要处理大量并发连接的高性能服务器和网络应用。</p><h3 id="epoll的事件触发有几种方式？"><a href="#epoll的事件触发有几种方式？" class="headerlink" title="epoll的事件触发有几种方式？"></a>epoll的事件触发有几种方式？</h3><p>epoll的事件触发主要有两种方式。第一种是边缘触发，也就是说，只有当文件描述符的状态从不就绪变为就绪时，epoll才会发出通知。一旦通知过后，除非状态再次发生变化，否则不会再次通知。第二种是水平触发，这种模式下，只要文件描述符处于就绪状态，epoll就会持续发出通知，直到数据处理完毕。</p><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I&#x2F;O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用，程序会一直执行 I&#x2F;O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>select&#x2F;poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p><p>另外，使用 I&#x2F;O 多路复用时，最好搭配非阻塞 I&#x2F;O 一起使用。</p><p>简单点理解，就是多路复用 API 返回的事件并不一定可读写的，如果使用阻塞 I&#x2F;O， 那么在调用 read&#x2F;write 时则会发生程序阻塞，因此最好搭配非阻塞 I&#x2F;O，以便应对极少数的特殊情况。</p><h1 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h1><p>减少数据在用户态和内核态之间的拷贝次数。</p><p>零拷贝技术是一种高效的数据传输技术，它的主要目的是减少数据在用户态和内核态之间的拷贝次数，从而降低CPU和内存的开销，提高数据传输的效率。在传统的数据传输过程中，数据通常需要在用户空间和内核空间之间进行多次拷贝，这不仅消耗了大量的CPU资源，还增加了内存带宽的占用。而零拷贝技术则能够避免这些不必要的数据拷贝。</p><p>具体来说，零拷贝技术可以通过一些特殊的系统调用来实现，如sendfile，mmap以及splice等。这些系统调用允许数据在内核空间和用户空间之间直接传输，而无需经过中间的拷贝过程。例如，sendfile系统调用可以在网络传输中实现零拷贝，它允许数据直接从内核缓冲区发送到网络接口，避免了数据在用户空间和内核空间之间的额外拷贝。</p><p>除了网络传输，零拷贝技术在文件操作，数据库操作，图像处理以及消息队列等场景也有广泛的应用。在这些场景中，零拷贝技术同样可以减少数据在应用程序和底层系统之间的拷贝次数，从而提高系统的性能和效率。</p><p>当然，零拷贝技术也并非没有缺点。例如，在某些情况下，由于需要直接操作内核空间的数据，因此可能会增加系统的复杂性和安全风险。此外，如果应用程序需要频繁地进行用户空间和内核空间之间的数据交换，那么零拷贝技术可能并不适合，因为它可能引入额外的系统调用开销。</p><hr><p>参考：</p><p><a href="https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8</a></p><p><a href="https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#epoll">https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#epoll</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。&lt;/p&gt;
&lt;h1 id=&quot;IO多路复用？select，poll，epoll的区别</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linjz.netlify.app/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="网络系统" scheme="https://linjz.netlify.app/tags/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-内存管理</title>
    <link href="https://linjz.netlify.app/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://linjz.netlify.app/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2024-03-22T03:15:34.000Z</published>
    <updated>2024-05-19T04:10:31.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。</p><h1 id="虚拟内存是什么？为什么要有虚拟内存？操作系统是如何管理虚拟内存的？"><a href="#虚拟内存是什么？为什么要有虚拟内存？操作系统是如何管理虚拟内存的？" class="headerlink" title="虚拟内存是什么？为什么要有虚拟内存？操作系统是如何管理虚拟内存的？"></a>虚拟内存是什么？为什么要有虚拟内存？操作系统是如何管理虚拟内存的？</h1><p>管理：分段，分页，多级页表，TLB</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是计算机系统内存管理的一种重要技术，简单来说，它使得应用程序认为自己拥有连续可用的内存空间，而实际上，这部分内存可能被分隔成多个物理内存碎片，甚至有部分数据被暂时存储在外部磁盘存储器上，当程序需要这些数据时，操作系统会将其从磁盘中读取到物理内存中。</p><h2 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h2><p>这种技术为我们提供了很多便利和优势。</p><p>首先，虚拟内存扩展了可用的内存容量。通过结合物理内存和硬盘空间，它允许大型应用程序运行，并为多任务操作系统提供了更好的支持。即使物理内存不足，系统也可以通过将未使用的数据移动到磁盘上来继续运行程序。</p><p>其次，虚拟内存提供了内存隔离，增加了数据的安全性和稳定性。每个进程都有自己的虚拟地址空间，这样一个进程就无法读取或修改另一个进程的数据。这种隔离保护了操作系统和应用程序免受潜在的安全威胁。</p><p>此外，虚拟内存还减少了程序之间的冲突。由于每个程序都在自己的地址空间中运行，因此不同的程序之间不会产生地址冲突。如果两个程序试图使用相同的内存地址，操作系统会检测到这种情况并防止数据损坏。</p><p>虚拟内存还通过页面置换技术提高了I&#x2F;O效率。当物理内存中的某些页面不再活跃时，它们会被移动到硬盘上，从而释放出物理内存空间给更活跃的应用程序使用。这不仅减少了I&#x2F;O操作的次数，还降低了硬盘访问时间，从而提高了整体的系统性能。</p><p>最后，虚拟内存技术还简化了内存管理，减轻了程序员的负担。程序员无需关心实际的物理内存布局和管理细节，可以更加专注于应用程序的开发和实现。</p><h2 id="操作系统是如何管理虚拟内存的？"><a href="#操作系统是如何管理虚拟内存的？" class="headerlink" title="操作系统是如何管理虚拟内存的？"></a>操作系统是如何管理虚拟内存的？</h2><p>虚拟内存管理是现代操作系统中非常重要的一部分，它允许程序使用比实际物理内存更大的内存空间，这种技术主要涉及到分段，分页，多级页表以及TLB等关键概念。</p><p>首先，我们来谈谈分段。在分段机制下，虚拟地址由两部分组成：段选择子和段内偏移量。段选择子用于指定要访问的段的起始位置和长度，而段内偏移量则表示在该段内的具体位置。操作系统会维护一个段表，记录了每个段的起始地址和长度等信息。当程序访问一个虚拟地址时，操作系统会通过段选择子从段表中找到对应的段描述符，进而计算出物理地址。</p><p>接下来是分页。分页是另一种重要的虚拟内存管理技术。操作系统会将物理内存和磁盘等辅助存储器中的空间划分成固定大小的区块，称为“页”。当程序需要更多的内存空间时，操作系统会将部分数据从物理内存中移到磁盘等辅助存储器上，而将当前需要的数据加载到物理内存中。这种机制使得程序可以透明地使用更大的内存空间，而无需关心实际物理内存的大小。同样的，操作系统也会维护一个页表，记录每个页的起始地址等信息。</p><p>然而，随着程序规模的扩大，页表也会变得非常庞大，这导致了查找效率的问题。为了解决这个问题，我们引入了多级页表的概念。多级页表将页表进行分级，通过分级索引的方式来定位具体的页框号。这种方式可以有效地减少页表所占用的空间，并提高查找效率。</p><p>最后，我们来谈谈TLB。TLB是一种高速缓存结构，用于加速虚拟内存到物理地址的转换过程。它保存了最近使用的虚拟地址和物理地址之间的映射关系。当CPU发出虚拟地址时，TLB会首先检查其中是否包含所需的物理地址。如果命中，则直接返回对应的物理地址；如果未命中，则需要访问操作系统的页表以获取映射关系，并将这些信息加载到TLB中以便下次快速访问。通过这种方式，TLB可以显著提高内存访问的性能。</p><p>综上所述，虚拟内存管理通过分段，分页，多级页表和TLB等技术实现了对物理内存的抽象和扩展，为程序提供了更大的内存空间并提高了内存访问的性能。</p><hr><p>参考：</p><p><a href="https://www.xiaolincoding.com/os/3_memory/vmem.html#_4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">https://www.xiaolincoding.com/os/3_memory/vmem.html#_4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98</a></p><p><a href="https://www.xiaolincoding.com/os/3_memory/vmem.html#%E6%80%BB%E7%BB%93">https://www.xiaolincoding.com/os/3_memory/vmem.html#%E6%80%BB%E7%BB%93</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。&lt;/p&gt;
&lt;h1 id=&quot;虚拟内存是什么？为什么要有虚拟内存？操作系统是如何管理</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linjz.netlify.app/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="内存管理" scheme="https://linjz.netlify.app/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-系统结构</title>
    <link href="https://linjz.netlify.app/2024/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <id>https://linjz.netlify.app/2024/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-20T13:31:53.000Z</published>
    <updated>2024-05-19T04:08:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。</p><h1 id="内核态和用户态的区别，为什么要划分？"><a href="#内核态和用户态的区别，为什么要划分？" class="headerlink" title="内核态和用户态的区别，为什么要划分？"></a>内核态和用户态的区别，为什么要划分？</h1><p>划分内核态和用户态是为了提高系统的安全性，稳定性和性能。这种划分使得操作系统能够更好的管理和保护系统资源，同时提供一个有效的机制来平衡系统的性能和安全性。</p><p>内核态和用户态是操作系统中的两种运行模式，它们之间有着明显的区别。简单来说，内核态是操作系统内核运行的模式，具有极高的权限，可以访问所有硬件资源和执行所有指令，包括特权指令。而用户态则是用户程序运行的模式，其权限受到限制，只能执行非特权指令，且不能直接访问操作系统内核数据结构和程序。</p><p>这两种状态的主要差别在于，处于用户态执行的程序不能直接访问操作系统内核数据结构和程序，其所处于占有的处理器是可被抢占的，且其能访问的内存空间和对象受到限制。而内核态下运行的程序则能访问所有的内存空间和对象，且所占有的处理器不允许被抢占。</p><p>那么，为什么要划分内核态和用户态呢？</p><p>1.安全性：通过划分内核态和用户态，可以防止用户程序对系统造成不可修复的破坏。因为用户程序在用户态下运行，其操作受到严格的限制，不能直接操作关键系统资源，从而保护了系统的安全性。</p><p>2.稳定性：如果用户程序崩溃或出现错误，由于它运行在用户态，因此不会影响整个系统的稳定性。内核态下运行的操作系统可以继续正常工作，而不受用户程序的干扰。</p><p>3.性能：虽然内核态和用户态之间的切换会耗费一定的性能资源，但这种划分也带来了性能上的优势。因为内核态具有更高的权限，可以执行一些需要较高特权级别的操作，如直接访问硬件，这有助于提高系统的性能。同时，通过将关键操作限制在内核态，可以确保这些操作的高效和准确执行。</p><h1 id="用户态陷入系统调用，切换到内核态的过程是怎么样的？哪些命令和函数会陷入到系统调用？"><a href="#用户态陷入系统调用，切换到内核态的过程是怎么样的？哪些命令和函数会陷入到系统调用？" class="headerlink" title="用户态陷入系统调用，切换到内核态的过程是怎么样的？哪些命令和函数会陷入到系统调用？"></a>用户态陷入系统调用，切换到内核态的过程是怎么样的？哪些命令和函数会陷入到系统调用？</h1><p>用户态陷入到系统调用并切换到内核态的过程是一个由用户程序主动发起，通过软中断触发，由操作系统内核接管并执行相应操作的过程。</p><p>切换过程：</p><p>当用户态陷入系统调用，切换到内核态的过程，首先是由用户态的进程主动发起一个系统调用请求，这个请求通常是由于用户态的程序需要执行一些只有操作系统内核才能完成的敏感或关键操作，比如访问硬件资源，进行进程间通信等。</p><p>在发起系统调用时，CPU会通过一个特殊的指令，比如x86架构中的int指令或者syscall指令，来触发一个软中断。这个软中断会导致CPU暂停当前用户态程序的执行，转而跳转到预先设定好的中断处理程序中去执行。</p><p>中断处理程序是操作系统内核的一部分，它在内核态中运行。当中断处理程序开始执行时，就意味着操作系统已经从用户态切换到了内核态。在内核态中，操作系统可以访问所有的硬件资源和系统数据，拥有最高的权限。</p><p>哪些命令和函数会陷入系统调用？</p><p>关于哪些命令和函数会陷入系统调用，实际上在Linux等类Unix系统中，很多常见的命令和函数最终都会陷入系统调用。比如，当我们使用open函数打开一个文件时，这个函数内部最终会调用系统提供的open系统调用来完成实际的文件打开操作。同样地，像read，write，close等文件操作函数，以及socket，bind，listen，accept等网络编程相关函数，它们底层都会陷入相应的系统调用来完成实际的工作。</p><hr><p>参考：</p><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14%20%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14%20%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md</a></p><p><a href="https://www.bilibili.com/video/BV16J411p7f1/?vd_source=7671cf3fe9ab7359cf92eaa34075e23d">https://www.bilibili.com/video/BV16J411p7f1/?vd_source=7671cf3fe9ab7359cf92eaa34075e23d</a></p><p><a href="https://www.cnblogs.com/wftop1/p/14972833.html#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A23%E7%A7%8D%E6%83%85%E5%86%B5">https://www.cnblogs.com/wftop1/p/14972833.html#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A23%E7%A7%8D%E6%83%85%E5%86%B5</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。&lt;/p&gt;
&lt;h1 id=&quot;内核态和用户态的区别，为什么要划分？&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linjz.netlify.app/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="系统结构" scheme="https://linjz.netlify.app/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="https://linjz.netlify.app/2024/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://linjz.netlify.app/2024/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2024-03-17T13:59:37.000Z</published>
    <updated>2024-05-19T03:12:40.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。</p><h1 id="进程，线程，协程的区别"><a href="#进程，线程，协程的区别" class="headerlink" title="进程，线程，协程的区别"></a>进程，线程，协程的区别</h1><p>进程，线程和协程在资源分配，调度，通信和开销等方面存在明显差异。</p><p><strong>进程</strong>是操作系统资源分配和调度的基本单位，拥有自己独立的内存空间和系统资源。进程间通信需要通过特殊的机制，如管道，消息队列，共享内存，信号量，信号，socket套接字等。由于进程拥有独立的内存空间，因此具有比较高的稳定性和安全性，但同时上下文切换的开销也比较大，需要保存和恢复整个进程的状态。</p><p><strong>线程</strong>是进程内的一个执行单元，也是CPU调度和分派的基本单位。同一进程下的所有线程共享这一进程的内存空间和系统资源。线程之间的通信更加高效，因为它们可以直接读写共享内存。线程的上下文切换开销比较小，只需要保存和恢复线程的上下文，而不是整个进程的状态。由于多个线程线程共享内存空间，所以存在数据竞争和线程安全问题，需要通过同步和互斥机制来解决。</p><p><strong>协程</strong>是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与，协程拥有自己的寄存器上下文和栈，与其他协程共享堆内存。协程的切换开销很小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换，这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相比于线程和进程来说，其编程模型更为复杂。</p><h1 id="进程上下文切换和线程上下文切换？操作系统都做了什么？"><a href="#进程上下文切换和线程上下文切换？操作系统都做了什么？" class="headerlink" title="进程上下文切换和线程上下文切换？操作系统都做了什么？"></a>进程上下文切换和线程上下文切换？操作系统都做了什么？</h1><p>进程上下文切换和线程上下文切换内容和发生场景有所不同，进程上下文切换涉及的内容更多，开销更大，主要发生在进程调用系统调用或者时间片用完等场景；而线程上下文切换主要涉及线程的执行状态和条件，发生在线程主动让出CPU，时间片用完或线程阻塞等场景。</p><p>进程上下文切换，在切换内容方面，进程上下文切换涉及的内容较为广泛。由于进程是操作系统中进行资源分配和调度的基本单位，它拥有自己的独立内存空间和系统资源，因此进程上下文切换不仅包含了<strong>虚拟内存，栈，全局变量</strong>等用户空间的资源，还包括了<strong>内核堆栈，寄存器</strong>等内核空间的资源，这些资源在切换时都需要被保存和恢复，以确保新进程能够在切换后顺序执行。</p><p>在发生场景上，进程上下文切换主要发生在以下几种情况，一是进程主动调度某些系统调用时，如等待IO完成或者获取锁，这时进程无法继续运行，操作系统会触发上下文切换；二是进程分配到的时间片用完，或者有更高优先级的进程需要抢占CPU时，也会发生上下文切换。</p><p>线程上下文切换，在切换内容方面，线程上下文切换主要涉及线程在执行过程中的运行条件和状态，如程序计数器，栈信息，寄存器的值等，由于线程共享进程的内存空间，因此线程上下文切换不需要像进程上下文切换那样涉及大量的内存和资源管理。</p><p>线程上下文切换发生场景主要包括：线程主动让出CPU，例如调用了Thread.sleep()或Object.wait()等方法；当一个线程的时间片用完，需要切换到另一个线程继续执行；或者线程因为阻塞或等待某个事件而无法继续执行时，调度器会切换到另一个线程继续执行。</p><h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助共享的<strong>内核空间</strong>来实现进程间通信，原因很简单，每个进程都是共享一个<strong>内核空间</strong>。</p><p>管道，消息队列，共享内存，信号量，套接字，信号</p><ul><li><p>管道是一种常见的进程间通信方式，它允许一个进程的输出作为另一个进程的输入。管道是半双工的，数据只能单向流动，且通常用于具有亲缘关系的进程之间，如父子进程。此外，还有命名管道，它与管道类似，但允许无亲缘关系的进程间进行通信。</p></li><li><p>消息队列，进程可以将消息发送到消息队列，其他进程则可以从队列中检索消息，这种方式克服了管道的一些限制，如只能承载无格式的字节流以及缓冲区大小受限等。消息队列允许进程之间发送和接收具有特定格式的消息，且可以异步地进行通信。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p></li><li><p>共享内存，多个进程可以访问同一块内存区域，从而直接读写共享的数据。这种方式速度非常快，因为数据不需要在不同进程之间复制，然而，它需要更复杂的同步机制来防止数据冲突和不一致性。</p></li><li><p>信号量是一种用于控制多个进程对共享资源的访问的同步机制，它可以被视为一个计数器，用于实现进程间的互斥和同步操作。信号量常用于保护对共享内存或其他资源的访问，以防止发生竞态条件。</p></li><li><p>套接字则是一种更为通用的进程间通信方式，它不仅适用于同一台计算机上的进程间通信，还适用于网络中的不同计算机上的进程间通信。套接字提供了一种标准的接口来发送和接收数据，支持多种协议（如TCP和UDP等），并具有跨平台和可靠性高的特点。</p></li><li><p>信号，它主要用于通知接收进程某个事件已经发生，信号是一种软件中断，可以由操作系统或其他进程发送，接收进程在收到信号后，可以根据信号的类型执行相应的操作，如<strong>1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SIGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。</p></li></ul><h1 id="管道的原理是什么？有名管道和匿名管道有啥区别？"><a href="#管道的原理是什么？有名管道和匿名管道有啥区别？" class="headerlink" title="管道的原理是什么？有名管道和匿名管道有啥区别？"></a>管道的原理是什么？有名管道和匿名管道有啥区别？</h1><p>管道是一种特殊的文件类型，具有读写两个端口，数据从一个端口流入，从另一个端口流出。管道的原理是基于内核缓冲区实现的，其本质是一个伪文件。当进程向管道写入数据时，数据首先被存储在内核缓冲区中，然后其他进程可以从该缓冲区读取数据，实现了进程间的数据共享和传输。</p><p>有名管道和匿名管道之间的主要区别在于它们的存在范围和使用方式。</p><p>有名管道也被称为FIFO，它在文件系统中具有一个路径名，并且可以被多个进程同时打开和使用，这意味着不相关的进程可以通过读写这个共享的文件来交换数据。有名管道是基于磁盘上实际的文件进行操作的，因此即使进程退出，管道依然存在。此外，多个进程可以同时向管道写入数据或从管道读取数据，这种特性使得有名管道成为进程间通信的重要手段之一，它常常用于解决在异步场景下进程间通信的问题。</p><p>相比之下，匿名管道是单向的，只能在具有亲缘关系的进程间使用，例如父子进程。它没有磁盘上对应的文件，只存在于内核中，因此读写速度非常快。匿名管道是基于内存进行操作的，主要用于实现进程间的同步和互斥，避免竞争条件和死锁等问题。当数据被写入匿名管道时，它会被存储在内核的缓冲区中，等待其他进程来读取。如果没有数据可读或管道已满，则相应的读写进程会被阻塞，直到有数据可读或管道中有空间可写为止。</p><h1 id="信号和信号量的区别"><a href="#信号和信号量的区别" class="headerlink" title="信号和信号量的区别"></a>信号和信号量的区别</h1><p>信号主要用于异步事件通知，而信号量则主要用于同步和互斥操作，以确保对共享资源的正确访问。</p><p>信号是一种处理异步事件的方式，<strong>用于通知接收进程有某种事件发生</strong>。信号是比较复杂的通信方式，它不仅可以用于进程间的通信，还可以发送给进程本身。在Unix和Linux系统中，信号被广泛应用于处理各种异步事件，如中断，异常或用户自定义的通知。信号是一种软件中断，允许一个进程向另一个进程或自身发送简短消息，通知某些事件发生，例如，一个程序可能因用户按下Ctrl+C而接收到SIGINT信号，表示需要中断执行。</p><p>信号量则是一种进程间通信处理同步互斥的机制，常用于多线程或多进程环境中。信号量负责协调各个线程或进程，以确保它们能够正确，合理地使用公共资源或关键代码段。信号量通常被用作一个计数器，用于控制对共享资源或临界区域的访问，它提供了两种基本操作：Wait（等待，有时也称为P操作）和Release（释放，有时也被称为V操作）。当某个进程或线程需要使用共享资源时，它会执行Wait操作，这将减少信号量的值，当资源使用完毕后，它会执行release操作，增加信号量的值。通过这种方式，信号量能够确保在同一时刻只有一个线程或进程能访问特定资源，从而防止资源冲突和数据不一致。</p><h1 id="死锁怎么产生的？怎么避免死锁？"><a href="#死锁怎么产生的？怎么避免死锁？" class="headerlink" title="死锁怎么产生的？怎么避免死锁？"></a>死锁怎么产生的？怎么避免死锁？</h1><p>死锁的必要条件：互斥条件；持有并等待条件；不可剥夺条件；环路等待条件。</p><p>避免死锁：打破其中一个条件即可。</p><p>死锁，是指在多进程或多线程系统中，两个或多个进程或线程因争夺资源而陷入无限等待的状态，无法继续执行下去。产生死锁必须同时满足以下四个条件：</p><p>首先是互斥条件。它意味着至少有一个资源必须处于非共享状态，即一次只能被一个进程或线程占用。如果其他进程或线程试图访问该资源，它们将被阻塞，直到资源被释放。</p><p>其次是持有并等待条件。这指的是进程或线程在持有至少一个资源的同时，还在等待其他资源。这个过程中，进程或线程并不会放弃自己的已经持有的资源，这就可能导致资源的占用和等待形成僵持状态。</p><p>第三个是不可剥夺条件。它表明已分配给进程或线程的资源不能被强制性地剥夺，只能由持有资源的进程或线程主动释放。这意味着即使其他进程或线程急需该资源，也无法从当前持有者那里强制取回。</p><p>最后是循环等待条件。存在一个进程或线程的资源申请序列，使得每个进程或线程都在等待下一个进程或线程所持有的资源，这形成了一个闭环，其中每个参与者都在等待链中的下一个参与者释放资源，从而导致所有参与者都无法继续执行。</p><p>当这四个条件同时满足时，就会发生死锁。</p><p>避免死锁：</p><p>为了避免死锁的发生，我们可以采取一些策略来破坏这些条件中的至少一个。</p><p>1.我们可以规定进程或线程在申请资源时必须一次性申请所有需要的资源，从而破坏持有并等待条件；</p><p>2.我们可以实现资源的超时机制，使得资源在一段时间后可以被强制剥夺，这样可以破坏不可剥夺条件；</p><p>3.我们可以对资源进行编号，并规定进程或线程必须按照编号的顺序申请资源，这样可以破坏循环等待条件。</p><p>通过这些方法，我们可以有效地预防和避免死锁的发生。</p><hr><p>参考：</p><p><a href="https://cloud.tencent.com/developer/article/1546730">https://cloud.tencent.com/developer/article/1546730</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/process_base.html#_5-1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">https://www.xiaolincoding.com/os/4_process/process_base.html#_5-1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">https://www.xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/process_base.html#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">https://www.xiaolincoding.com/os/4_process/process_base.html#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/process_commu.html#_5-2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">https://www.xiaolincoding.com/os/4_process/process_commu.html#_5-2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93">https://www.xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7">https://www.xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7%E9%87%8F">https://www.xiaolincoding.com/os/4_process/process_commu.html#%E4%BF%A1%E5%8F%B7%E9%87%8F</a></p><p><a href="https://www.xiaolincoding.com/os/4_process/deadlock.html#_5-4-%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81">https://www.xiaolincoding.com/os/4_process/deadlock.html#_5-4-%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在复习操作系统相关的知识，顺便整理归纳一些比较重要的点。&lt;/p&gt;
&lt;h1 id=&quot;进程，线程，协程的区别&quot;&gt;&lt;a href=&quot;#进程，线</summary>
      
    
    
    
    <category term="操作系统" scheme="https://linjz.netlify.app/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程管理" scheme="https://linjz.netlify.app/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>服务网格初识</title>
    <link href="https://linjz.netlify.app/2024/02/23/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%88%9D%E8%AF%86/"/>
    <id>https://linjz.netlify.app/2024/02/23/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%88%9D%E8%AF%86/</id>
    <published>2024-02-23T12:21:11.000Z</published>
    <updated>2024-03-01T13:43:48.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务网格初识"><a href="#服务网格初识" class="headerlink" title="服务网格初识"></a>服务网格初识</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者所在实习公司小组近期在做后端架构升级，有幸参加了相应方案评审及分享，于是整理了一下相应内容并写下对应笔记在这里分享。</p><h2 id="服务网格的定义"><a href="#服务网格的定义" class="headerlink" title="服务网格的定义"></a>服务网格的定义</h2><p><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html"> 服务网格</a>是一个<strong>基础设施层</strong>，用于处理服务间通信，是云原生下微服务的解决方案。云原生应用有着复杂的服务拓扑，服务网格负责在这些拓扑中实现<strong>请求的可靠传递</strong>。在实践中，服务网格通常实现为一组<strong>轻量级网络代理</strong>，它们与应用程序部署在一起，而<strong>对应用程序透明。</strong></p><ul><li>本质：基础设施层</li><li>功能：请求的可靠传递</li><li>部署形态：轻量级网络代理 Sidecar</li><li>特点：和业务逻辑完全解耦</li></ul><h2 id="服务网格-Service-Mesh-的产生与演进"><a href="#服务网格-Service-Mesh-的产生与演进" class="headerlink" title="服务网格(Service Mesh)的产生与演进"></a>服务网格(Service Mesh)的产生与演进</h2><p>要想快速理解一个全新陌生的概念，我个人感觉还是得先从熟悉的入手或者根据其演化过程看其出现是为了解决什么问题，那让我们从应用程序的发展来了解服务网格的出现吧！</p><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>应用程序发展的早期，大部分web工程师将所有的功能模块打包到一起并放在一个web容器中运行，所有功能模块使用同一个数据库。各个客户端请求server服务器，所有的业务逻辑都是在这个server端内完成，这是常见的网络请求模型架构，对于小型的服务而言，这个架构是最合适的，因为它稳定且简单，server服务器的更新和维护也很简单。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229210432845.png" alt="image-20240229210432845"></p><h3 id="集群架构（单体架构扩展）"><a href="#集群架构（单体架构扩展）" class="headerlink" title="集群架构（单体架构扩展）"></a>集群架构（单体架构扩展）</h3><p>随着我们的用户数渐渐变多，单台服务器的压力扛不住的时候，我们就要用到负载均衡技术，增加多台服务器来抗压，后端的数据库也可以用主从同步的方式来增加并发量，模型如下图所示：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229210529111.png" alt="image-20240229210529111"></p><h3 id="微服务一代"><a href="#微服务一代" class="headerlink" title="微服务一代"></a>微服务一代</h3><p>虽然单体的集群架构能解决一部分并发问题，但是随着业务的发展，依然存在其他严重的问题：</p><ul><li>单体应用代码库庞大，不易于理解和修改</li><li>持续部署困难，由于单体应用各组件间依赖性强，只要其中任何一个组件发生更改，将重新部署整个应用，而频繁的部署将增加服务宕机的风险，因此频繁地进行部署几乎不可能</li><li>扩展应用困难，单体应用只能从一个维度进行扩展，即很容易通过增加实例副本提供处理能力。另一方面，单体应用各个组件对资源的使用情况需求不同，一些是CPU密集型，另一些是内存密集型，但是不能独立地扩展单个组件</li><li>阻碍快速开发，随着公司业务的发展，单体服务框架变得更加庞大，更多的部门将会参与系统的开发，但是各个部门又不能独立开发、维护相应的模块，即使其中一个部门完成相应的更新，仍然不能上线，因此需要花费更多时间在部门间协调和统一。还有，需要增加新的功能时，单体应用最初的设计限制开发人员灵活选择开发语言、工具等，导致新功能上线慢</li><li>迫使开发人员长期专注于一种技术栈，由于单体应用本身设计的原因，后期引入新的技术栈需要遵循最开始的设计，因此存在非常大的局限性、挑战性，否则可能需要重写整个框架</li></ul><p>针对上面问题的出现，微服务架构应运而生，将单体应用拆分后由多个微服务构建的复杂系统，系统中各个微服务之间彼此通过网络进行通信，很好地解决了上述问题。而微服务中最大的挑战便是如何以标准化的方式管理微服务以及如何保证复杂网络环境中微服务间的可靠通信，确保整个系统的最大可用性，提供尽可能高的SLA。</p><blockquote><p>SLA（Service Level Agreement）意思是服务等级协议，是关于网络服务供应商和客户间的一份合同，其中定义了服务类型、服务质量和客户付款等术语。</p></blockquote><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/img_v3_028i_31f8ac8e-9971-4527-a074-28f778b8225g.jpg" alt="image-20240229210810171"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229210959817.png" alt="image-20240229210959817"></p><p>每个微服务由两部分构成：</p><ul><li>业务逻辑：定义如何处理应用业务逻辑</li><li>网络功能：网络功能部分主要负责服务间的通信，包括上述列出的构建分布式高可用的技术实现，如超时、重试、服务发现、负载均衡等</li></ul><p>优点：</p><ul><li>分而治之，职责单一：易于开发、理解和维护、方便团队的拆分和管理</li><li>错误和故障隔离：当微服务架构隔离功能时，它也会隔离错误。一个微服务中的问题不会关闭整个应用程序，它将包含在该区域中，而其他微服务继续运行。</li><li>弹性可伸缩：能够单独的对指定的服务进行伸缩</li><li>局部容易修改，容易替换，容易部署，有利于持续集成和快速迭代</li><li>不会受限于任何技术栈</li></ul><p>缺点：</p><ul><li>网络功能与业务逻辑耦合性很高，每个应用都需封装负载均衡、服务发现、安全通信以及分布式追踪等功能</li><li>灵活性差，复用率低下，不同的应用需要重复实现</li><li>管理复杂，当其中一项如负载均衡逻辑发生变化，需要更新所有服务</li><li>可运维性低，所有组件均封装在业务逻辑代码中，不能作为一个独立运维对象</li><li>对开发人员能力要求很高</li></ul><h3 id="微服务二代"><a href="#微服务二代" class="headerlink" title="微服务二代"></a>微服务二代</h3><p>第一阶段中，网络控制逻辑和业务逻辑耦合严重，随着不断发展，考虑将应用处理服务发现、负载均衡、分布式追踪、安全通信等设计为一个公用库，从而使得应用与这些功能具有更低的耦合性，而且更加灵活、提高利用率及运维性，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。（例如java的SpringCloud ，将服务发现、服务治理、流量控制等逻辑抽并整合在一起形成一个新的工具类库）</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229211337238.png" alt="image-20240229211337238"></p><h3 id="Service-Mesh一代"><a href="#Service-Mesh一代" class="headerlink" title="Service Mesh一代"></a>Service Mesh一代</h3><p>第二代微服务模式看似完美，但开发人员很快又发现，它也存在一些本质问题：</p><ul><li>虽然框架本身屏蔽了分布式系统通信的一些通用功能实现细节，但开发者却要花更多精力去掌握和管理复杂的框架本身，在实际应用中，去追踪和解决框架出现的问题也绝非易事</li><li>开发框架通常只支持一种或几种特定的语言，回过头来看文章最开始对微服务的定义，一个重要的特性就是语言无关，但那些没有框架支持的语言编写的服务，很难融入面向微服务的架构体系，想因地制宜的用多种语言实现架构体系中的不同模块也很难做到</li><li>框架以lib库的形式和服务联编，复杂项目依赖时的库版本兼容问题非常棘手，同时，框架库的升级也无法对服务透明，服务会因为和业务无关的lib库升级而被迫升级</li></ul><p>因此以Linkerd，Envoy，NginxMesh为代表的代理模式（边车模式）应运而生，这就是第一代Service Mesh，它将分布式服务的通信抽象为单独一层，在这一层中实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能，作为一个和服务对等的代理服务，和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求，这样上边所说的三个问题也迎刃而解。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229211501496.png" alt="image-20240229211501496"></p><p>从一个全局视角来看，就会得到如下部署图：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229211524412.png" alt="image-20240229211524412"></p><h3 id="Service-Mesh二代"><a href="#Service-Mesh二代" class="headerlink" title="Service Mesh二代"></a>Service Mesh二代</h3><p>第一代Service Mesh由一系列独立运行的单机代理服务构成，为了提供统一的上层运维入口，演化出了集中式的<strong>控制面板</strong>，所有的单机代理组件通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报。这就是以<a href="https://istio.io/latest/zh/docs/setup/getting-started/">istio</a>为代表的第二代Service Mesh。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229211718175.png" alt="image-20240229211718175"></p><p>只看单机代理组件(数据面板)和控制面板的Service Mesh全局部署视图如下，我们看到实际的服务流量仍然直接从代理流向代理，但控制平面管理着每个代理实例，使代理能够实现访问控制和指标收集等功能。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229212134509.png" alt="image-20240229212134509"></p><h2 id="服务网格的架构"><a href="#服务网格的架构" class="headerlink" title="服务网格的架构"></a>服务网格的架构</h2><p>大致了解了服务网格的由来及其解决的问题，现在可以来看看其架构了。</p><p>服务网格(Service Mesh)架构如下：</p><ul><li><strong>数据平面</strong> ：由一组智能代理组成， 被部署为 Sidecar。这些代理负责协调和控制微服务之间的所有网络通信。 它们还收集和报告所有网格流量的遥测数据。</li><li><strong>控制平面</strong> ：控制和管理数据平面的 <a href="https://www.zhaowenyu.com/istio-doc/GLOSSARY.html#sidecar">sidecar</a> 代理，完成配置的分发、服务发现、授权鉴权等功能。</li></ul><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229211718175.png" alt="image-20240229211718175"></p><p>每个服务都将有一个配套的代理 sidecar，鉴于服务仅通过 sidecar 代理相互通信，我们最终得到类似于下图的部署:</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229212123438.png" alt="image-20240229212123438"></p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ul><li>流量控制<ul><li>路由、流量转移</li><li>超时重试、熔断</li><li>故障注入</li><li>流量镜像</li><li>灰度发布、蓝绿发布</li><li>请求转发</li></ul></li><li>策略<ul><li>流量限制</li><li>黑白名单</li></ul></li><li>安全<ul><li>授权</li><li>身份认证</li></ul></li><li>可观测性<ul><li>指标收集和展示</li><li>日志收集</li><li>分布式追踪</li></ul></li></ul><h2 id="Service-Mesh和Kubernetes-k8s-的关系"><a href="#Service-Mesh和Kubernetes-k8s-的关系" class="headerlink" title="Service Mesh和Kubernetes(k8s) 的关系"></a>Service Mesh和Kubernetes(k8s) 的关系</h2><p>Kubernetes</p><ul><li>解决容器编排与调度问题</li><li>本质上是管理应用生命周期(调度器)</li><li>给予 Service Mesh 支持和帮助</li></ul><p>Service Mesh</p><ul><li>解决服务间网络通信问题</li><li>本质上是管理服务通信(代理)</li><li>是对Kubernetes网络功能方面的扩展和延伸</li></ul><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E5%8F%8AIstio%E5%88%9D%E8%AF%86.assets/image-20240229212316557.png" alt="image-20240229212316557"></p><h2 id="Service-Mesh选择思考"><a href="#Service-Mesh选择思考" class="headerlink" title="Service Mesh选择思考"></a>Service Mesh选择思考</h2><p>服务网格的前景是非常美好的，当一个系统的代码只包含业务逻辑，其他业务无关的技术问题都在基础设施层面解决，不用再引入多到数不清的依赖包以及跨预言而烦恼。然而构建基础设施，可谓牵一发而动全身。看起来业界大厂对于服务网格的探索结果都挺香，但那是基于强大的中间件团队和云原生技术储备下的。如果是小规模尝试，使用开源的解决方案比如Istio也是可以尝试的。</p><p>在nginx的文章中<a href="https://www.nginx.com/blog/how-to-choose-a-service-mesh/">how-to-choose-a-service-mesh</a>对于什么时候选择服务网格主要有三点供参考：</p><ul><li>已经完全应用Kubernetes</li><li>有大型的分布式应用程序</li><li>频繁的部署成熟的CI&#x2F;CD</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务网格初识&quot;&gt;&lt;a href=&quot;#服务网格初识&quot; class=&quot;headerlink&quot; title=&quot;服务网格初识&quot;&gt;&lt;/a&gt;服务网格初识&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="云原生" scheme="https://linjz.netlify.app/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>COLA架构初探</title>
    <link href="https://linjz.netlify.app/2024/02/17/COLA%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2/"/>
    <id>https://linjz.netlify.app/2024/02/17/COLA%E6%9E%B6%E6%9E%84%E5%88%9D%E6%8E%A2/</id>
    <published>2024-02-17T13:28:55.000Z</published>
    <updated>2024-02-28T14:39:55.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="COLA架构初探"><a href="#COLA架构初探" class="headerlink" title="COLA架构初探"></a>COLA架构初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于笔者实习公司所接触到的项目架构是阿里开源的COLA架构，于是自己上网学习并记录下这篇笔记，以更好的理解公司的项目。</p><h2 id="COLA概述"><a href="#COLA概述" class="headerlink" title="COLA概述"></a>COLA概述</h2><p><strong>COLA 是 Clean Object-Oriented and Layered Architecture的缩写，代表“整洁面向对象分层架构”。</strong> </p><p>在COLA 4.0，也就是目前最新的版本中，作者将COLA拆分为COLA架构（Archetype）和COLA组件（Components）两个部分：</p><ul><li>COLA架构：COLA应用的代码模板。</li><li>COLA组件：提供一些非常有用的通用组件，这些组件可以帮助我们提升研发效率。</li></ul><p><strong>两者互不干扰，可以独立使用。</strong></p><h3 id="COLA整体架构"><a href="#COLA整体架构" class="headerlink" title="COLA整体架构"></a>COLA整体架构</h3><p>自从COLA诞生以来，已经被使用在很多的业务系统里面，有CRM的业务，有电商的业务，有物流的业务，有外卖业务，有排课系统… COLA作为应用架构，有一定的普适性，是因为业务问题都有一定的共性。例如，典型的业务系统都需要：</p><p>​1.接收request，响应response；<br>​2.做业务逻辑处理，像校验参数，状态流转，业务计算等等；<br>​3.和外部系统有联动，像数据库，微服务，搜索引擎等；</p><p>正是有这样的共性存在，才会有很多普适的架构思想出现，比如分层架构、六边形架构、洋葱圈架构、整洁架构（Clean Architecture）、DDD架构等等。</p><p>这些应用架构思想虽然很好，但我们很多同学还是“不讲Co德，明白了很多道理，可还是过不好这一生”。问题就在于缺乏实践和指导。COLA的意义就在于，他不仅是思想，还提供了可落地的实践。应该是为数不多的应用架构层面的开源软件。</p><p><strong>COLA提供了一整套代码架构，拿来即用。</strong> 其中包含了很多架构设计思想，包括讨论度很高的领域驱动设计DDD等。</p><h3 id="COLA分层架构"><a href="#COLA分层架构" class="headerlink" title="COLA分层架构"></a>COLA分层架构</h3><p>先来看几张官方介绍图</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/ef77ed67d11c3fd61feaaf7e9757b19c.jpeg" alt="img"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/f648283f63d0fb2a868c49fb20a82b64.jpeg" alt="img"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/2450ba6358e9e68cb5b91f50ef3a7b0b.png" alt="image.png"></p><p>其次，还有一个官方的表格，介绍了COLA中每个层的命名和含义：</p><table><thead><tr><th align="left">层次</th><th align="left">包名</th><th align="left">功能</th><th align="left">必选</th></tr></thead><tbody><tr><td align="left">Adapter层</td><td align="left">web</td><td align="left">处理页面请求的Controller</td><td align="left">否</td></tr><tr><td align="left">Adapter层</td><td align="left">wireless</td><td align="left">处理无线端的适配</td><td align="left">否</td></tr><tr><td align="left">Adapter层</td><td align="left">wap</td><td align="left">处理wap端的适配</td><td align="left">否</td></tr><tr><td align="left">App层</td><td align="left">executor</td><td align="left">处理request，包括command和query</td><td align="left">是</td></tr><tr><td align="left">App层</td><td align="left">consumer</td><td align="left">处理外部message</td><td align="left">否</td></tr><tr><td align="left">App层</td><td align="left">scheduler</td><td align="left">处理定时任务</td><td align="left">否</td></tr><tr><td align="left">Domain层</td><td align="left">model</td><td align="left">领域模型</td><td align="left">否</td></tr><tr><td align="left">Domain层</td><td align="left">ability</td><td align="left">领域能力，包括DomainService</td><td align="left">否</td></tr><tr><td align="left">Domain层</td><td align="left">gateway</td><td align="left">领域网关，解耦利器</td><td align="left">是</td></tr><tr><td align="left">Infra层</td><td align="left">gatewayimpl</td><td align="left">网关实现</td><td align="left">是</td></tr><tr><td align="left">Infra层</td><td align="left">mapper</td><td align="left">ibatis数据库映射</td><td align="left">否</td></tr><tr><td align="left">Infra层</td><td align="left">config</td><td align="left">配置信息</td><td align="left">否</td></tr><tr><td align="left">Client SDK</td><td align="left">api</td><td align="left">服务对外透出的API</td><td align="left">是</td></tr><tr><td align="left">Client SDK</td><td align="left">dto</td><td align="left">服务对外的DTO</td><td align="left">是</td></tr></tbody></table><p>你可能会有疑问，为什么Domain的model是可选的？因为COLA是应用架构，不是<a href="https://zhuanlan.zhihu.com/p/464914100">DDD架构</a>。在工作中，很多同学问我领域模型要怎么设计，我的回答通常是：无有必要勿增实体。领域模型对设计能力要求很高，没把握用好，一个错误的抽象还不如不抽象，宁可不要用，也不要滥用，不要为了DDD而DDD。</p><p>问题的关键是要看，新增的模型没有给你带来收益。比如有没有帮助系统解耦，有没有提升业务语义表达能力的提升，有没有提升系统的可维护性和可测性等等。</p><p>模型虽然可选，但DDD的思想是一定要去学习和贯彻的，特别是统一语言、边界上下文、防腐层的思想，值得深入学习，仔细体会。实际上，COLA里面的很多设计思想都来自于DDD。其中就包括领域包的设计。</p><p>前面的包定义，都是功能维度的定义。为了兼顾领域维度的内聚性，我们有必要对包结构进行一下微调，即顶层包结构应该是按照领域划分，让领域内聚。</p><p>也就是说，我们要综合考虑功能和领域两个维度包结构定义。按照领域和功能两个维度分包策略，最后呈现出来的，是如下图所示的顶层包节点是领域名称，领域之下，再按功能划分包结构。<br><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/9f42fc75bfb4f670c6f047b9907ff174.png" alt="image.png"></p><p>既然整个示例架构项目是一个Maven父子结构，那我们就从父模块一个个好好过一遍。</p><p>首先父模块的pom.xml包含了如下子模块：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;demo-web-client&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;demo-web-adapter&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;demo-web-app&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;demo-web-domain&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;demo-web-infrastructure&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">module</span>&gt;start&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><h4 id="start层"><a href="#start层" class="headerlink" title="start层"></a>start层</h4><p>该模块作为整个应用的启动模块（通常是一个SpringBoot应用），只承担启动项目和全局相关配置项的存放职责。代码目录如下：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/3cff8261e6952884dc4f3d7d2042c3a7.jpeg" alt="img"></p><p>将启动独立出来，好处是清晰简洁，也能让新人一眼就看出如何运行项目，以及项目的一些基础依赖。</p><h4 id="adapter层"><a href="#adapter层" class="headerlink" title="adapter层"></a>adapter层</h4><p>接下来我们按照之前架构图从上到下的顺序，一个个看。</p><p>首先是demo-web-adapter模块，这名字是不是很新鲜？但其实，可以理解为平时我们用的controller层（对于Web应用来说），换汤不换药。</p><p>在COLA官方博客中，也能找到如下的描述：</p><blockquote><p>Controller这个名字主要是来自于MVC，因为是MVC，所以自带了Web应用的烙印。然而，随着mobile的兴起，现在很少有应用仅仅只支持Web端，通常的标配是Web，Mobile，WAP三端都要支持。</p></blockquote><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/a4a34663d6378f77d9d522430aeb6628.jpeg" alt="img"></p><h4 id="cilent层"><a href="#cilent层" class="headerlink" title="cilent层"></a>cilent层</h4><p>有了我们说的“controller”层，接下来有的小伙伴肯定就会想，是不是service层啦。</p><p><strong>是，也不是。</strong></p><p>传统的Web应用中，完全可以只有一个service层给controller层调用，但是作为一个业务应用，除非你真的只是个前端页面的无情吐数据机器，否则很大可能性你的应用会有很多其他上下游调用方，并且你需要提供接口给他们。</p><p>这时候你给他们的不应该是一个Web接口，应该是RPC调用的服务层接口，至于原因不是本文的重点，具体就不展开了。</p><p>所以在COLA中，你的adapter层，调用了client层，client层中就是你服务接口的定义。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/5487aa16fb5e12c7d7182c6d288e3240.jpeg" alt="img"></p><p>从上图中可以看到，client包里有：</p><ul><li>api文件夹：存放服务接口定义</li><li>dto文件夹：存放传输实体</li></ul><p>注意，这里只是服务接口定义，而不是服务层的具体实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomerServiceI customerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/customer&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MultiResponse&lt;CustomerDTO&gt; <span class="title function_">listCustomerByName</span><span class="params">(<span class="meta">@RequestParam(required = false)</span> String name)</span>&#123;</span><br><span class="line">        <span class="type">CustomerListByNameQry</span> <span class="variable">customerListByNameQry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerListByNameQry</span>();</span><br><span class="line">        customerListByNameQry.setName(name);</span><br><span class="line">        <span class="keyword">return</span> customerService.listByName(customerListByNameQry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终接口的具体实现逻辑放到了app层。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CatchAndLog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CustomerServiceI</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomerListByNameQryExe customerListByNameQryExe;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MultiResponse&lt;CustomerDTO&gt; <span class="title function_">listByName</span><span class="params">(CustomerListByNameQry customerListByNameQry)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customerListByNameQryExe.execute(customerListByNameQry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="app层"><a href="#app层" class="headerlink" title="app层"></a>app层</h4><p>接着上面说的，我们的app模块作为服务的具体实现，存放了各个业务的实现类，<strong>并且严格按照业务分包</strong>，这里划重点，<strong>是先按照业务分包，再按照功能分包的</strong>，直接看图：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/472d5aa096341b2615649335fd23017f.jpeg" alt="img"></p><p>customer和order分别对应了消费着和订单两个业务子领域。里面是COLA定义app层下面三种功能：</p><table><thead><tr><th align="left">App层</th><th align="left">executor</th><th align="left">处理request，包括command和query</th><th align="left">是</th></tr></thead><tbody><tr><td align="left"><strong>App层</strong></td><td align="left"><strong>consumer</strong></td><td align="left"><strong>处理外部message</strong></td><td align="left"><strong>否</strong></td></tr><tr><td align="left"><strong>App层</strong></td><td align="left"><strong>scheduler</strong></td><td align="left"><strong>处理定时任务</strong></td><td align="left"><strong>否</strong></td></tr></tbody></table><p>可以看到，消息队列的消费者和定时任务，这类平时我们业务开发经常会遇到的场景，也放在app层。</p><h4 id="domain层"><a href="#domain层" class="headerlink" title="domain层"></a>domain层</h4><p>接下来便是domain，也就是领域层，先看一下领域层整体结构：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/5338206765cd6e1816026c04eaddfe31.jpeg" alt="img"></p><p>可以看到，首先是按照不同的领域（customer和order）分包，里面则是三种主要的文件类型：</p><ol><li><p>领域实体：实体模型可以是<a href="https://zhuanlan.zhihu.com/p/464914100">充血模型</a>，例如官方示例里的Customer.java如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String customerId;</span><br><span class="line">    <span class="keyword">private</span> String memberId;</span><br><span class="line">    <span class="keyword">private</span> String globalId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registeredCapital;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">private</span> SourceType sourceType;</span><br><span class="line">    <span class="keyword">private</span> CompanyType companyType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBigCompany</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registeredCapital &gt; <span class="number">10000000</span>; <span class="comment">//注册资金大于1000万的是大企业</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSME</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registeredCapital &gt; <span class="number">10000</span> &amp;&amp; registeredCapital &lt; <span class="number">1000000</span>; <span class="comment">//注册资金大于10万小于100万的为中小企业</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkConfilict</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//Per different biz, the check policy could be different, if so, use ExtensionPoint</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;ConflictCompanyName&quot;</span>.equals(<span class="built_in">this</span>.companyName))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="built_in">this</span>.companyName+<span class="string">&quot; has already existed, you can not add it&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>领域能力：domainservice文件夹下，是领域对外暴露的服务能力，如上图中的CreditChecker。</p></li><li><p>领域网关：gateway文件夹下的接口定义，这里的接口你可以粗略的理解成一种SPI，也就是交给infrastructure层去实现的接口。</p></li></ol><p>例如CustomerGateway里定义了接口getById，要求infrastructure的实现类必须定义如何通过消费者Id获取消费者实体信息，而infrastructure层可以实现任何数据源逻辑，比如，从MySQL获取，从Redis获取，还是从外部API获取等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerGateway</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">getById</span><span class="params">(String customerId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在示例代码的CustomerGatewayImpl（位于infrastructure层）中，CustomerDO（数据库实体）经过MyBatis的查询，转换为了Customer领域实体，进行返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerGatewayImpl</span> <span class="keyword">implements</span> <span class="title class_">CustomerGateway</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomerMapper customerMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">getById</span><span class="params">(String customerId)</span>&#123;</span><br><span class="line">      <span class="type">CustomerDO</span> <span class="variable">customerDO</span> <span class="operator">=</span> customerMapper.getById(customerId);</span><br><span class="line">      <span class="comment">//Convert to Customer</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="infrastructure层"><a href="#infrastructure层" class="headerlink" title="infrastructure层"></a>infrastructure层</h4><p>最后是我们的infrastructure也就是基础设施层，这层有我们刚才提到的gatewayimpl网关实现，也有MyBatis的mapper等数据源的映射和config配置文件。</p><table><thead><tr><th align="left">Infra层</th><th align="left">gatewayimpl</th><th align="left">网关实现</th><th align="left">是</th></tr></thead><tbody><tr><td align="left"><strong>Infra层</strong></td><td align="left"><strong>mapper</strong></td><td align="left"><strong>ibatis数据库映射</strong></td><td align="left"><strong>否</strong></td></tr><tr><td align="left"><strong>Infra层</strong></td><td align="left"><strong>config</strong></td><td align="left"><strong>配置信息</strong></td><td align="left"><strong>否</strong></td></tr></tbody></table><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/3d06c00b3f4e46aeb725a1cbf0476fcf.jpeg" alt="img"></p><p>所有层讲完了，COLA4.0很简单明了，<strong>最后，在引用一段官方介绍博客原文来总结COLA的层级：</strong></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/1a4e5210301a669f74bff8801e3d9e1d.png" alt="image.png"></p><blockquote><p>1）适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，对于传统B&#x2F;S系统而言，adapter就相当于MVC中的controller；</p><p>2）应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层；</p><p>3）领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次；</p><p>4）基础实施层（Infrastructure Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。</p></blockquote><h2 id="COLA架构的特色"><a href="#COLA架构的特色" class="headerlink" title="COLA架构的特色"></a>COLA架构的特色</h2><p>说完了分层架构，我们再来回顾下上面提到的COLA架构的几个特色的设计</p><h3 id="领域与功能的分包策略"><a href="#领域与功能的分包策略" class="headerlink" title="领域与功能的分包策略"></a>领域与功能的分包策略</h3><p>也就是下面这张图的意思，先按照领域分包，再按照功能分包，这样做的其中一点好处是能将腐烂控制在该业务域内。</p><p>比如消费者customer和订单order两个领域是两个后端开发并行开发，两个人对于dto，util这些文件夹的命名习惯都不同，那么只会腐烂在各自的业务包下面，而不会将dto,util,config等文件夹放在一起，极容易引发文件冲突。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/466b4faf859ffb35c098a2204d1f7339.jpeg" alt="img"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/775ebf5081b287439c6d1c0e66247496.jpeg" alt="img"></p><blockquote><p>前面的包定义，都是功能维度的定义。为了兼顾领域维度的内聚性，我们有必要对包结构进行一下微调，即顶层包结构应该是按照领域划分，让领域内聚。</p></blockquote><h3 id="业务域和外部依赖解耦"><a href="#业务域和外部依赖解耦" class="headerlink" title="业务域和外部依赖解耦"></a>业务域和外部依赖解耦</h3><p>前面提到的domain和infrastructure层的依赖倒置，是一个非常有用的设计，进一步解耦了取数逻辑的实现。</p><p>例如下图中，你的领域实体是商品item，通过gateway接口，你的商品的数据源可以是数据库，也可以是外部的服务API。</p><p>如果是外部的商品服务，你经过API调用后，商品域吐出的是一个大而全的DTO（可能包含几十个字段），而在下单这个阶段，订单所需要的可能只是其中几个字段而已。你拿到了外部领域DTO，转为自己领域的Item，只留下标题价格库存等必要的数据字段。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/183d9f99596e13f0d292c633fc05236d.jpeg" alt="img"></p><h3 id="COLA并不完美"><a href="#COLA并不完美" class="headerlink" title="COLA并不完美"></a>COLA并不完美</h3><p>诚然，COLA已经做的足够清晰简洁了，但是它仍然有不完美的地方，比如每个接口的出入参都会根据业务名做定义，导致了很多结构极为相似的DTO，DTO的爆炸增长是个问题。参考：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/alibaba/COLA/issues/271&source=article&objectId=1971122">ISSUE-271</a></p><p>但是总的来说，COLA只是给你提供了一种架构设计的思想，并不深入到强制你使用某种规范的层面，所以对于COLA中你觉得复杂，或者不理解的地方，很多时候需要你自己来做权衡，作取舍。<strong>取其精华，去其糟粕</strong>的运用到你的项目中。</p><h2 id="COLA的使用"><a href="#COLA的使用" class="headerlink" title="COLA的使用"></a>COLA的使用</h2><h3 id="COLA-Archetype的使用"><a href="#COLA-Archetype的使用" class="headerlink" title="COLA Archetype的使用"></a>COLA Archetype的使用</h3><p>以上就是COLA架构的核心内容了。然而这么多module，这么多package，如果要手动去创建的话，是非常繁琐和费时的。为了能够快速创建满足COLA架构的应用，作者创建了两个Maven Archetype。</p><ol><li>一个是用来创建纯后端服务的archetype：cola-archetype-service。</li><li>一个是用来创建adapter和后端服务一体的web应用archetype：cola-archetype-web。</li></ol><p>这两个的区别就是下面那个会多一个模块adapter来适配多端。</p><p>另外，你也可以使用阿里云的应用生成器去生成一个COLA应用，只是那边的版本没有同步更新，可能会老旧一点。</p><p><strong>具体使用</strong></p><p>第一步 相关依赖安装</p><p>需要先安装好<a href="https://blog.csdn.net/u011029104/article/details/131856831?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170912505616800182184424%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170912505616800182184424&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131856831-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=git%E5%AE%89%E8%A3%85window&spm=1018.2226.3001.4187">Git</a>，<a href="https://blog.csdn.net/weixin_47260194/article/details/122595008?ops_request_misc=&request_id=&biz_id=102&utm_term=jdk%E5%AE%89%E8%A3%85window&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-122595008.142%5Ev99%5Epc_search_result_base6&spm=1018.2226.3001.4187">JDK</a>和<a href="https://blog.csdn.net/swadian2008/article/details/113530102?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170912491416777224450642%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170912491416777224450642&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113530102-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=Maven%E5%AE%89%E8%A3%85window&spm=1018.2226.3001.4187">Maven</a>。</p><p>第二步 生成相应框架</p><p>打开cmd</p><p>在想要的项目位置下，输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.linjz.demo -DartifactId=LinJzCOLADemo -Dversion=1.0.0-SNAPSHOT -Dpackage=com.linjz.demo -DarchetypeArtifactId=cola-framework-archetype-web -DarchetypeGroupId=com.alibaba.cola -DarchetypeVersion=4.0.0</span><br></pre></td></tr></table></figure><p>上面的这段命令的一些参数是可以修改的</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240228212319119.png" alt="image-20240228212319119"></p><p>前三个就是idea创建项目窗口的如下3个参数，最后一个是COLA框架的版本，可官网查看最新版本以及对应版本信息</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223110925087.png" alt="image-20240223110925087"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/Snipaste_2024-02-28_22-35-48.png" alt="image-20240223115813431"></p><p>整个过程在手动输入一个y就可以了</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223141803601.png" alt="image-20240223141803601"></p><p>第三步 启动运行测试Demo</p><p>找到项目路径，用idea打开运行项目就可以了</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223142454778.png" alt="image-20240223142454778"></p><p>在浏览器中输入 <a href="http://localhost:8080/helloworld">http://localhost:8080/helloworld</a> 进行测试即可</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240228210648698.png" alt="image-20240228210648698"></p><p>到这里就可以在这个项目框架的基础上，进行自己业务代码的填充啦！！</p><h3 id="COLA-组件使用"><a href="#COLA-组件使用" class="headerlink" title="COLA 组件使用"></a>COLA 组件使用</h3><p>之前，这种框架功能和架构混淆在一起，会让人以为使用COLA，就必须要使用这些功能。实际上二者是可以分开使用的，也就是说，你可以单纯的使用COLA架构，而不使用任何COLA组件提供的功能也是完全没问题的。</p><p>为了方便管理，以及更清晰的把架构和框架区分开来。在此次COLA 4.0的升级中，作者把这些功能组件全部收拢到了cola-components下面。到目前为止，官方已经沉淀了以下组件：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240228211039091.png" alt="image-20240228211039091"></p><p><strong>具体使用</strong></p><p>第一步 拉取代码看具体组件实现</p><p><a href="https://github.com/alibaba/COLA">https://github.com/alibaba/COLA</a></p><p>先从github仓库拉取代码观看有哪些组件是自己想要使用的，当然不拉取全部代码也行，不影响，因为我们使用只是导入相关依赖调用包而已！</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223112253418.png" alt="image-20240223112253418"></p><p>第二步 在自己的项目中导入想要使用的组件的依赖就可以使用组件了</p><p>比如添加COLA的状态机器组件如下，直接调用其提供的方法就可以了，具体实现可以参看源码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.alibaba.cola&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;cola-component-statemachine&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">4.4</span><span class="number">.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="安装可能遇到的坑"><a href="#安装可能遇到的坑" class="headerlink" title="安装可能遇到的坑"></a>安装可能遇到的坑</h2><p>在文件夹中直接打开的PowerShell没法直接运行会报错说没有pom文件</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223115913007.png" alt="image-20240223115913007"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223115954270.png" alt="image-20240223115954270"></p><p>然后我想是不是得在一个有pom文件的下面执行，是不是得拉下COLA的源码，所以我拉下源码然后直接进入到COLA那个项目下执行</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223120458658.png" alt="image-20240223120458658"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223120515512.png" alt="image-20240223120515512"></p><p>还是失败，然后网上查了一下，说可以使用命令提示符</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223115503255-17086768565401.png" alt="image-20240223115503255"></p><p>然后打开命令提示符却发现，怎么也没法进入到我想要的路径</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223120712288.png" alt="image-20240223120712288"></p><p>网上查了一下说得加一个&#x2F;d就可以解决了</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/COLA%E6%9E%B6%E6%9E%84/COLA%E6%9E%B6%E6%9E%84.assets/image-20240223111459005.png" alt="image-20240223111459005"></p><p>参考：</p><p><a href="https://github.com/alibaba/COLA/issues/295">https://github.com/alibaba/COLA/issues/295</a></p><p><a href="https://blog.csdn.net/m0_55034727/article/details/121554973">https://blog.csdn.net/m0_55034727/article/details/121554973</a></p><p><a href="https://cloud.tencent.com/developer/article/1971122">https://cloud.tencent.com/developer/article/1971122</a></p><p><a href="https://blog.csdn.net/significantfrank/article/details/110934799">https://blog.csdn.net/significantfrank/article/details/110934799</a></p><p><a href="https://github.com/alibaba/COLA">https://github.com/alibaba/COLA</a></p><p><a href="https://www.jianshu.com/p/6a00d6912f45">https://www.jianshu.com/p/6a00d6912f45</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;COLA架构初探&quot;&gt;&lt;a href=&quot;#COLA架构初探&quot; class=&quot;headerlink&quot; title=&quot;COLA架构初探&quot;&gt;&lt;/a&gt;COLA架构初探&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="架构" scheme="https://linjz.netlify.app/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>kerberos认证</title>
    <link href="https://linjz.netlify.app/2024/02/08/kerberos%E8%AE%A4%E8%AF%81/"/>
    <id>https://linjz.netlify.app/2024/02/08/kerberos%E8%AE%A4%E8%AF%81/</id>
    <published>2024-02-08T12:59:56.000Z</published>
    <updated>2024-02-28T14:39:17.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kerberos认证"><a href="#kerberos认证" class="headerlink" title="kerberos认证"></a>kerberos认证</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于笔者所在实习公司部门是大数据部门，需要接触到大数据核心组件Hadoop，而Hadoop 使用 <strong>Kerberos</strong> 作为<strong>用户和服务的强身份验证和身份传播</strong>的基础，所以为了更好理解所接手的项目，自行上网了解kerberos认证并记录下这篇笔记。</p><h1 id="Kerberos概述"><a href="#Kerberos概述" class="headerlink" title="Kerberos概述"></a>Kerberos概述</h1><p>强大的身份验证和建立用户身份是 Hadoop 安全访问的基础。用户需要能够可靠地 “识别” 自己，然后在整个 Hadoop 集群中传播该身份。完成此操作后，这些用户可以访问资源（例如文件或目录）或与集群交互（如运行 MapReduce 作业）。除了用户之外，Hadoop 集群资源本身（例如主机和服务）需要相互进行身份验证，以避免潜在的恶意系统或守护程序 “冒充” 受信任的集群组件来获取数据访问权限。</p><p>Hadoop 使用 <strong>Kerberos</strong> 作为<strong>用户和服务的强身份验证和身份传播</strong>的基础。<strong>Kerberos 是一种计算机网络认证协议，它允许某实体在非安全网络环境下通信，向另一个实体以一种安全的方式证明自己的身份。</strong> Kerberos 是第三方认证机制，其中用户和服务依赖于第三方（Kerberos 服务器）来对彼此进行身份验证。 <strong>Kerberos服务器</strong>本身称为<strong>密钥分发中心或 KDC</strong>。 在较高的层面上，它有三个部分：</p><ul><li>它知道的用户和服务（称为<strong>主体</strong>）及其各自的 Kerberos 密码的数据库。</li><li>一个<strong>认证服务器（Authentication Server，简称 AS）：验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张票证授予票证（Ticket Granting Ticket，简称 TGT）给 Client。</strong></li><li>一个<strong>票据授权服务器（Ticket Granting Server，简称 TGS）：通过 TGT（AS 发送给 Client 的票）获取访问 Server 端的票（Server Ticket，简称 ST）。ST（Service Ticket）也有资料称为 TGS Ticket。</strong></li></ul><p>以平时坐火车举例：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/kerberos%E8%AE%A4%E8%AF%81/kerberos%E8%AE%A4%E8%AF%81.assets/16d7b6c7aa155076tplv-t2oaga2asx-jj-mark3024000q75.awebp" alt="img"></p><p>一个用户主要来自AS请求认证。AS <strong>返回</strong> 使用用户主体 的 Kerberos密码加密 的 <strong>TGT</strong> ，该密码仅为用户主体和 AS 所知。用户主体使用其 Kerberos 密码在本地解密TGT，从这时起，直到 <strong>ticket</strong> 到期，用户主体都可以使用 TGT （个人认证）从 TGS （票务中心）获取服务票据，也就是去往某个地方的火车票。<strong>服务票证允许委托人访问服务。</strong></p><p>Kerberos 简单来说就是一个用于安全认证第三方协议，它采用了传统的共享密钥的方式，实现了在网络环境不一定保证安全的环境下，client 和 server 之间的通信，适用于 client&#x2F;server 模型，由 MIT 开发和实现。</p><p>Kerberos 服务是<strong>单点登录</strong>系统，这意味着您对于每个会话只需向服务进行一次自我验证，即可自动保护该会话过程中所有后续事务的安全。</p><p>由于每次解密 TGT 时群集资源（主机或服务）都无法提供密码，因此它们使用称为 <strong>keytab</strong> 的特殊文件，<strong>该文件包含资源主体的身份验证凭据</strong>，也就是在这个keytab有效期内，可以拿着这个keytab去票务中心领取某地的火车票而不需要去AS进行身份认证。</p><p>Kerberos 服务器控制的<strong>主机，用户和服务集</strong>称为<strong>领域</strong>。</p><h1 id="Kerberos验证过程"><a href="#Kerberos验证过程" class="headerlink" title="Kerberos验证过程"></a>Kerberos验证过程</h1><p>Kerberos 验证分为两个阶段：允许进行后续验证的初始验证以及所有后续验证自身。</p><h2 id="初始验证：票证授予票证（也就是向AS拿到身份认证TGT）"><a href="#初始验证：票证授予票证（也就是向AS拿到身份认证TGT）" class="headerlink" title="初始验证：票证授予票证（也就是向AS拿到身份认证TGT）"></a>初始验证：票证授予票证（也就是向AS拿到身份认证TGT）</h2><p>下图显示了如何进行初始验证：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/kerberos%E8%AE%A4%E8%AF%81/kerberos%E8%AE%A4%E8%AF%81.assets/16d7b6c7f2f465fbtplv-t2oaga2asx-jj-mark3024000q75.awebp" alt="img"></p><ul><li><p>客户端通过从密钥分发中心(Key Distribution Center, KDC)请票证授予票证(Ticket-Granting Ticket, TGT)开始 Kerberos 会话。此请求通常在登录时自动完成。</p><p>要获取特定服务的其他票证，需要 TGT 。票证授予票证类似于护照。与护照一样，TGT 可标识您的身份并允许您获取多个“签证”，此处的“签证”（票证）不是用于外国，而是用于远程计算机或网络服务。与护照和签证一样，票证授予票证和其他各种票证具有有限的生命周期。区别在于基于 Kerberos 的命令会通知您拥有护照并为您取得签证。您不必亲自执行该事务。</p><p>与票证授予票证类似的另一种情况是可以在四个不同的滑雪场使用的三天滑雪入场卷。只要入场券未到期，您就可以在决定要去的任意一个滑雪场出示入场卷，并获取该滑雪场提供的缆车票。获取缆车票后，即可在该滑雪场随意滑雪。如果第二天去另一个滑雪场，您需要再次出示入场卷，并获取新滑雪场的另一张缆车票。区别在于基于 Kerberos 的命令会通知您拥有周末滑雪入场卷，并会为您取得缆车票。因此，您不必亲自执行该事务。</p></li><li><p>KDC 可创建 TGT ，并采用加密形式将其发送回客户端。客户端使用其口令来解密 TGT 。</p></li><li><p>拥有有效的 TGT，只要该 TGT 未到期，客户机便可以请求所有类型的网络操作（如 rlogin 或 telnet）的票证。此票证的有效期通常为一天。每次客户端执行唯一的网络操作时，都将从 KDC 请求该操作的票证。</p></li></ul><h2 id="后续Kerberos验证（也就是向TGS拿到去往某地的火车票ST，然后去往某地）"><a href="#后续Kerberos验证（也就是向TGS拿到去往某地的火车票ST，然后去往某地）" class="headerlink" title="后续Kerberos验证（也就是向TGS拿到去往某地的火车票ST，然后去往某地）"></a>后续Kerberos验证（也就是向TGS拿到去往某地的火车票ST，然后去往某地）</h2><p>客户机收到初始验证后，每个后续验证都按下图所示的模式进行。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/kerberos%E8%AE%A4%E8%AF%81/kerberos%E8%AE%A4%E8%AF%81.assets/16d7b6c84e537e53tplv-t2oaga2asx-jj-mark3024000q75.awebp" alt="img"></p><ul><li><p>客户机通过向 KDC 发送其 TGT 作为其身份证明，从 KDC 请求特定服务（例如，远程登录到另一台计算机）的票证ST。</p></li><li><p>客户机从KDC获取对应服务的ST。</p><p>例如，假定用户 <code>joe</code> 要访问已通过要求的 <code>krb5</code> 验证共享的 NFS 文件系统。 由于该用户已经通过了验证（即，该用户已经拥有票证授予票证TGT），因此当其尝试访问文件时， 用户客户机系统将自动透明地从 KDC 获取 NFS 服务的票证ST。</p><p>又如，假定用户 <code>joe</code> 在服务器 <code>boston</code> 上使用 rlogin。由于该用户已经通过了验证（即，该用户已经拥有票证授予票证TGT），所以在运行 rlogin 命令时，该用户客户机将自动透明地获取服务器 <code>boston</code> 的票证ST。该用户使用此票证可随时远程登录到 <code>boston</code>，直到票证到期为止。如果 <code>joe</code> 要远程登录到计算机 <code>denver</code>，则需要按照步骤 1 获取服务器<code>denver</code>票证ST。</p></li><li><p>客户机将票证ST发送到服务器。</p><p>使用 NFS 服务时，客户机会自动透明地将 NFS 服务的票证ST发送到 NFS 服务器。</p></li><li><p>服务器允许此客户机（用户）进行访问。</p></li></ul><p>从这些步骤来看，整个过程，服务器似乎并未与 KDC 通信，用户想要访问这个服务时，把从KDC获取到的TGT交给KDC获取该服务的ST，在这个ST有效期间内，用户都可以拿着这个ST访问该服务，无需重复获取ST，服务器验证本服务ST，允许用户访问。</p><p>但服务器实际上与 KDC 进行过通信，并向 KDC 注册了其自身，KDC才有这个服务的ST，也就是初始验证阶段，向AS获取TGT的过程，客户机（本服务器）获得TGT，KDC也存储本服务的ST，等待其他客户机拿着自己的TGT来索要本服务的ST。</p><h2 id="认证过程通俗解释"><a href="#认证过程通俗解释" class="headerlink" title="认证过程通俗解释"></a>认证过程通俗解释</h2><p>前面认证的介绍可能有点难以理解，我在知乎找到了一篇回答，非常通俗易懂，相信看了下面这个小故事可以很容易把前面讲的给串接起来，更好的理解kerberos认证原理。</p><p>很久很久以前，在Kerberos王国有一个神奇的王，它的名字叫KDC，国号为秦（域名），为了更好地管理臣民（用户）、管理营业性场所（文件共享服务器、邮件服务器、打印服务器等），要求臣民、营业性场所到王室领取一个账号，账号主要包括用户名&#x2F;密码。</p><p>有一个臣民叫王老虎，账号名为“王老虎”，密码“xxxxxxxx”, 那么在Kerberos王国里，有几个人知道王老虎的密码？</p><p>一个是王老虎本人，另一个就是王，即KDC。还有其他人知道吧？没有了！</p><p>有一家提供文件共享的服务场所，名字叫“小美共享文件服务社”，密码是“xxxxxxx”，这个账号的密码，在KDC王国，只有2个人知道，一个是自己，另外一个就是王，KDC。</p><p>KDC王颁布以下规定：</p><p>（1）臣民去臣民家拜访，需要先到KDC票务中心买票，只有买到了被拜访者家的票（Service Ticket)，才能前往拜访。</p><p>（2）臣民前去营业场所消费，同样需要先到KDC购票入场。</p><p>（3）营业场所去营业场所消费，一样也需要购票入场。</p><p>现在王老虎想去“小美文件服务社”坐坐，并浏览一下文件，能直接冲进去吗？</p><p>不能。</p><p>王老虎先到KDC票务中心买票，票务中心说：请问你是哪位？</p><p>王老虎！</p><p>票务中心：请用王老虎的密钥加密“一段认证信息”发给我！</p><p>王老虎照做！</p><p>票务中心知道王老虎的密钥，成功解密王老虎的加密信息，认证成功！</p><p>上文说了，在这个世界上除了KDC知道王老虎的密钥，另外一个就是王老虎本人了。</p><p>既然KDC用王老虎的密钥解密成功，那说明加密信息的密钥肯定是王老虎的，间接表明买票的人，肯定是王老虎。</p><p>以上只是KDC验证王老虎的过程，问题来了，王老虎如何知道KDC票务中心不是假冒的？</p><p>很简单，玄机就在“一段认证信息”里了，这“一段认证信息”里，王老虎想写啥就写啥，王老虎是这样写的：</p><p>“知乎到底能走多远？”</p><p>由于这段信息是用王老虎的密钥发给KDC的，如果KDC是真的，那么自然可以解密到明文信息，然后把王老虎的“知乎到底能走多远？”返回给王老虎，那么王老虎就知道对方是真的KDC。</p><p>双向认证成功，可以避免任何一方是假冒的安全风险。</p><p>既然认证成功，那么KDC就为王老虎出票呗。KDC给王老虎2件东西：</p><p>(1）用王老虎密钥加密的session key</p><p>(2) “小美文件服务社”门票（Service Ticket)</p><p>这个门票是用“小美文件服务社”的密钥加密的，里面包含 :</p><p>A) 和王老虎一样的session key</p><p>B) 门票持有人姓名：王老虎</p><p>C) 王老虎属于哪个Group</p><p>上文1、2 中的session key 是一样的。</p><p>接下来王老虎就直奔小美处了，王老虎敲敲小美的门，小美说：先生请出示您的门票。</p><p>王老虎出示2样东西：</p><p>（1）门票Ticket</p><p>（2）用session key 加密“一段认证信息”，认证信息里写道：“美女，你会说相声不？”</p><p>小美用自己的密钥解密ticket，得到上文ABC信息。</p><p>小美用解密得到的A &#x3D; session key ，解密（2），得到明文认证信息：“美女，你会说相声不？”</p><p>小美对王老虎说：“美女，你会说相声不？”</p><p>王老虎窃喜，看来这个小美不是假冒的，否则不可能知道我加密的认证信息！</p><p>至此，双向认证成功，接下来就使用双方都知道的session key 来加密&#x2F;解密双向的流量，由于session key 只有KDC、王老虎、小美知晓，任何第三方都无法知晓session key，所以无法解密流量。</p><p>上文忘记说了，小美的每一个文件都具有权限管理，小美根据上文的C，可以知道王老虎属于哪个group，看看这个group有没有被访问文件的“ read 、write 、modify、full control”权限，并依据特定权限，限制王老虎操作文件的特权。</p><h1 id="Kerberos基本概念"><a href="#Kerberos基本概念" class="headerlink" title="Kerberos基本概念"></a>Kerberos基本概念</h1><h2 id="Key-Distribution-Center-or-KDC"><a href="#Key-Distribution-Center-or-KDC" class="headerlink" title="Key Distribution Center, or KDC"></a>Key Distribution Center, or KDC</h2><p>在启用Kerberos的环境中进行身份验证的受信任源。</p><h2 id="Kerberos-KDC-Server"><a href="#Kerberos-KDC-Server" class="headerlink" title="Kerberos KDC Server"></a>Kerberos KDC Server</h2><p>作为密钥分发中心（KDC）的计算机或服务器。</p><h2 id="Kerberos-Client"><a href="#Kerberos-Client" class="headerlink" title="Kerberos Client"></a>Kerberos Client</h2><p>集群中针对KDC进行身份验证的任何计算机。</p><h2 id="KDC-Admin-Account"><a href="#KDC-Admin-Account" class="headerlink" title="KDC Admin Account"></a>KDC Admin Account</h2><p>Ambari用于在KDC中创建主体并生成密钥表的管理帐户。</p><h2 id="Principal"><a href="#Principal" class="headerlink" title="Principal"></a>Principal</h2><p>Kerberos principal（又称为<strong>主体</strong>）用于在kerberos加密系统中标记一个唯一的身份。<strong>主体</strong>可以是<strong>用户</strong>（如<code>joe</code>）或<strong>服务</strong>（如<code>namenode</code>或<code>hive</code>）。</p><p>根据约定，主体名称分为三个部分：<strong>主名称、实例和领域</strong>。例如，典型的Kerberos主体可以是<code>joe/admin@EXAMPLE.COM</code>。在本实例中：</p><ul><li><p><code>joe</code>是主名称。主名称可以是此处所示的用户名或namenode等服务。</p></li><li><p><code>admin</code>是实例。对于用户主体，实例是可选的；但对于服务主体，实例则是必需的。例如，如果用户 <code>joe</code> 有时充当系统管理员，则他可以使用 <code>joe/admin</code> 将其自身与平时的用户身份区分开来。同样，如果 <code>joe</code> 在两台不同的主机上拥有帐户，则他可以使用两个具有不同实例的主体名称，例如 <code>joe/node1.example.com</code> 和 <code>joe/node2.example.com</code>。请注意，Kerberos 服务会将 <code>joe</code> 和 <code>joe/admin</code> 视为两个完全不同的主体。</p><p>对于服务主体，实例是全限定主机名。例如，<code>node1.example.com</code>就是这种实例。</p></li><li><p><code>EXAMPLE.COM</code>是Kerberos领域。领域将在下一小节中介绍。</p></li></ul><p>Hadoop中的<strong>每个服务和子服务</strong>都必须有自己的<strong>主体</strong>。给定领域中的<strong>主体名称</strong>由<strong>主名称</strong>和<strong>实例名称</strong>组成，在这种情况下，<strong>实例名称</strong>是运行该服务的主机的<a href="https://blog.csdn.net/u012842205/article/details/51931017">FQDN</a>。由于服务未使用密码登录以获取其票证TGT，因此其主体的身份验证凭据存储在<code>keytab</code>密钥表文件中，该文件从Kerberos数据库中提取并本地存储在服务组件主机上具有服务主体的安全目录中。比如<code>NameNode</code>组件在<code>node1.example.com</code>主机上，启用<code>kerberos</code>之后，会自动生成<code>nn.service.keytab</code>文件，并存储在<code>/etc/security/keytabs</code>目录下，用户所有者是<code>hdfs:hadoop</code>，权限为<code>400</code>，如图所示：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/kerberos%E8%AE%A4%E8%AF%81/kerberos%E8%AE%A4%E8%AF%81.assets/16d7b6c8a6818c46tplv-t2oaga2asx-jj-mark3024000q75.awebp" alt="img"></p><p>ambari 和 hadoop service 的 principals 都存储 Kerberos KDC 中，如下图所示：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/kerberos%E8%AE%A4%E8%AF%81/kerberos%E8%AE%A4%E8%AF%81.assets/16d7b6c8ef7d7797tplv-t2oaga2asx-jj-mark3024000q75.awebp" alt="img"></p><p><strong>Principal和Keytab命名约定</strong></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/kerberos%E8%AE%A4%E8%AF%81/kerberos%E8%AE%A4%E8%AF%81.assets/image-20240225154149244.png" alt="image-20240225154149244"></p><p>请注意前面的示例中每个服务主体的主名称。这些主要名称（例如nn或hive）分别代表NameNode或Hive服务。每个主要名称都附加了实例名称，即运行它的主机的FQDN。此约定为在多个主机（如DataNodes和NodeManager）上运行的服务提供唯一的主体名称。添加主机名用于区分，例如，来自DataNode A的请求与来自DataNode B的请求。这一点很重要，原因如下：</p><ul><li>一个 DataNode 的受损 Kerberos 凭据不会自动导致所有 DataNode 的 Kerberos 凭据受损。</li><li>如果多个 DataNode 具有完全相同的主体并同时连接到 NameNode ，并且正在发送的 Kerberos 身份验证器恰好具有相同的时间戳，则身份验证将作为重播请求被拒绝。</li></ul><p><strong>Ambari Principals</strong></p><p>除了 Hadoop 服务主体之外，Ambari 本身还需要一组 Ambari Principal 来执行服务“<strong>冒烟</strong>”检查，执行警报运行状况检查以及从集群组件检索指标。 Ambari Principals 的 Keytab 文件驻留在每个群集主机上，就像服务主体的 keytab 文件一样。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/kerberos%E8%AE%A4%E8%AF%81/kerberos%E8%AE%A4%E8%AF%81.assets/image-20240225154228033.png" alt="image-20240225154228033"></p><h2 id="realms-name"><a href="#realms-name" class="headerlink" title="realms name"></a>realms name</h2><p>包含 KDC 和许多客户端的 Kerberos 网络，类似于域，俗称为领域。</p><h2 id="keytab"><a href="#keytab" class="headerlink" title="keytab"></a>keytab</h2><p>keytab 是包含 principals 和加密 principal key 的文件。</p><p>keytab 文件对于每个 host 是唯一的，因为 key 中包含 hostname 。keytab 文件用于不需要人工交互和保存纯文本密码，实现到 kerberos 上验证一个主机上的 principal 。</p><p>因为服务器上可以访问 keytab 文件即可以以 principal 的身份通过 kerberos 的认证，所以，keytab 文件应该<strong>被妥善保存，应该只有少数的用户可以访问。</strong></p><h2 id="ticket（票证）"><a href="#ticket（票证）" class="headerlink" title="ticket（票证）"></a>ticket（票证）</h2><p>ticket 是一种信息包，用于将用户身份安全地传递到服务器或服务。一个票证仅对一台客户机以及某台特定服务器上的一项特殊服务有效。票证包含以下内容：</p><ul><li>服务的主体名称</li><li>用户的主体名称</li><li>用户主机的 IP 地址</li><li>时间标记</li><li>定义票证生命周期的值</li><li>会话密钥的副本</li></ul><p>所有此类数据都使用服务器的服务密钥进行加密。颁发票证之后，可重用票证直到其到期为止。</p><h2 id="credential（凭证）"><a href="#credential（凭证）" class="headerlink" title="credential（凭证）"></a>credential（凭证）</h2><p>是一种信息包，其中包含票证和匹配的会话密钥。凭证使用发出请求的主体的密钥进行加密。通常，KDC 会生成凭证以响应客户机的票证请求。</p><h2 id="authenticator（验证者）"><a href="#authenticator（验证者）" class="headerlink" title="authenticator（验证者）"></a>authenticator（验证者）</h2><p>是服务器用于验证客户机用户主体的信息。 验证者包含用户的主体名称、时间标记和其他数据。 与票证不同，验证者只能使用一次，通常在请求访问服务时使用。 验证者使用客户机和服务器共享的会话密钥进行加密。 通常，客户机会创建验证者，并将其与服务器或服务的票证一同发送，以便向服务器或服务进行验证。</p><h1 id="票证生命周期"><a href="#票证生命周期" class="headerlink" title="票证生命周期"></a>票证生命周期</h1><p>每当主体获取包括票证授予票证 (Ticket–Granting Ticket, TGT) 在内的票证时，可以通过 kinit 的 <strong>-l</strong> 选项指定的生命周期值，前提是使用 kinit 获取票证。缺省情况下，kinit 使用最长生命周期值。kdc.conf 文件中指定的最长生命周期值 (max_life)。</p><p>可通过 kinit 的 <strong>-r</strong> 选项指定的可更新生命周期值，前提是使用 kinit 获取或更新票证。kdc.conf 文件中指定的最长可更新生命周期值 (max_renewable_life)。</p><p>参考：</p><p><a href="https://juejin.cn/post/6844903955416219661">https://juejin.cn/post/6844903955416219661</a></p><p><a href="https://www.zhihu.com/question/22177404/answer/492680179">https://www.zhihu.com/question/22177404/answer/492680179</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kerberos认证&quot;&gt;&lt;a href=&quot;#kerberos认证&quot; class=&quot;headerlink&quot; title=&quot;kerberos认证&quot;&gt;&lt;/a&gt;kerberos认证&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="大数据" scheme="https://linjz.netlify.app/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>大数据架构演进</title>
    <link href="https://linjz.netlify.app/2024/02/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
    <id>https://linjz.netlify.app/2024/02/02/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</id>
    <published>2024-02-02T12:04:44.000Z</published>
    <updated>2024-02-28T14:38:22.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据架构演进"><a href="#大数据架构演进" class="headerlink" title="大数据架构演进"></a>大数据架构演进</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者所在实习公司部门是大数据部门，需要接触到大数据相关概念，比如Hadoop，hive，Sprark，Flink，Trino，Doris等组件以及流批一体，湖仓一体等架构，面对着这些扑面而来的陌生名词，由于之前从未接触过大数据开发相关领域，所以一下子会有点无从入手，但是好在有幸能读到内网分享的一篇大数据架构演进文章，才对这些名词以及部门未来方向有些初步了解，于是整理笔记在这里分享！</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1998 年，一篇名为《大数据科学的可视化》的文章在美国《自然》杂志上发表，大数据作为一个专用名词正式出现在公共刊物之中，至今已经发展了二十余年。根据维基百科的定义，大数据是指无法在可承受的时间范围内用常规软件工具进行处理的数据集合，具有规模性（Volume）、多样性（Varity）、高速性（Velocity）和价值性（Value）等四个方面的典型特征，即所谓的 “4V”。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225170252852.png" alt="image-20240225170252852"></p><p>为了有效解决大规模数据存储、计算、分析的诸多难点，诞生了以 Hadoop 为代表的一系列产品，整个大数据生态系统庞大而复杂，而大数据架构则是连接、组织这一庞大生态的核心。在大数据的下一个十年即将来临之际，本文将对这二十年中具有代表性的大数据架构进行一个阶段性总结，回顾历史，拥抱未来。</p><h1 id="大数据架构的早期发展"><a href="#大数据架构的早期发展" class="headerlink" title="大数据架构的早期发展"></a>大数据架构的早期发展</h1><p>在上世纪 90 年代，随着互联网浪潮带动的数据持续增长，传统的数据库技术遇到了瓶颈。美国的 Teradata 天睿公司推出了可以储存 TB 级数据的关系型数据库管理系统，这是对 MPP（大规模并行处理）架构的最初雏形使用。这一时期，大数据系统主要以存储结构化数据为主，处在一个缓慢发展的阶段。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225170407950.png" alt="image-20240225170407950"></p><p>1990 年，Bill Inmon 提出了数据仓库这一概念：面向主题的、集成的、随时间变化的、非易失的数据集合，用于支持管理者的决策。很多大型企业开始着手搭建自己的数据仓库。但是受限于技术，这一时期只能将业务数据库的数据通过 ETL 管道抽取到基于关系型数据库搭建的数据仓库中，分析手段十分有限。</p><blockquote><p>ETL，是英文Extract-Transform-Load的缩写，用来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程。ETL一词较常用在数据仓库，但其对象并不限于数据仓库。</p></blockquote><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225170424835.png" alt="image-20240225170424835"></p><p>真正给大数据体系带来变革的，是 Hadoop 的出现。</p><h2 id="Hadoop的发展史"><a href="#Hadoop的发展史" class="headerlink" title="Hadoop的发展史"></a>Hadoop的发展史</h2><p>Hadoop 的发展可以追溯到 2001 年，当时 Lucene 框架被创建，这是一个用 Java 写的开源软件，提供了全文搜索功能。</p><p>2003 年，Nutch 项目启动，它的目标是创建一个开源的搜索引擎，包括网页抓取、索引、查询等功能。然而，随着网页数量的增加，Nutch 遇到了可扩展性的问题。</p><p>同年，Google 发表了关于 GFS 的论文，这是一种分布式文件系统，可用于处理海量网页的存储。</p><p>2004 年，Google 又发表了关于 MapReduce 的论文，这是一种分布式计算框架，可用于处理海量网页的索引计算问题。这为解决 Nutch 的可扩展性问题提供了可能。</p><p>2005 年，Lucene 的子项目 Nutch 的一部分正式引入 Apache 基金会。同年，Hadoop 成为 Lucene 的子项目。</p><p>2006 年，Google 发表了关于 Bigtable 的论文，这是一种分布式数据库，可以在局部几台服务器崩溃的情况下继续提供高性能的服务。</p><p>2008 年 1 月，Hadoop 成为 Apache 顶级项目，迎来了它的快速发展期。</p><p>大数据三驾马车：分布式文件系统，分布式计算，分布式数据库。</p><p>现在，Hadoop 已经发展成为一个包括 HDFS、MapReduce、HBase 等众多项目的庞大生态系统。有趣的是，Hadoop 这一名字的来源是作者 Doug Cutting 的儿子的玩具大象，因此 Hadoop 生态的很多组件的 logo 上都出现了黄色大象这一元素。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225173203692.png" alt="image-20240225173203692"></p><h2 id="Hadoop-生态下的离线数仓架构"><a href="#Hadoop-生态下的离线数仓架构" class="headerlink" title="Hadoop 生态下的离线数仓架构"></a>Hadoop 生态下的离线数仓架构</h2><p>下面我们来具体介绍一下基于 Hadoop 体系的传统大数据架构。</p><p>在 Hadoop 生态发展初期，一个主流的解决方案是通过 Flume、Sqoop 等工具，将数据以 ETL 的形式抽取到 HDFS （分布式文件系统）中，并通过 MapReduce （分布式计算框架）完成数据计算。</p><p>MapReduce 虽然解决了大规模数据场景下的分布式计算这一问题，但是存在很多缺陷：</p><ul><li>数据计算过程中产生的数据大量落盘，磁盘 IO 严重，性能不佳</li><li>基于 Map 和 Reduce 接口的编程模型过于简单，很多复杂的业务逻辑难以实现，开发者无法专注于业务逻辑的编写</li><li>MapReduce 作业需要使用 Java 语言进行开发并打包部署，存在很高的技术门槛，整体的开发效率非常低下</li><li>无法迭代式计算，不能够很好的支持机器学习场景的任务</li></ul><p>2007 年，Facebook 研发了数据仓库工具 Hive，在一定程度上解决了 MapReduce 的一些问题。Hive 是建立在 HDFS 之上的，支持标准化 SQL，并自动转换为 MapReduce 任务，屏蔽了底层框架细节，而且在存储层、计算层都做了不少的优化。</p><p>2008 年，Hive 正式开源，很快成为大数据领域构建离线数仓的统一标准。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225173600949.png" alt="image-20240225173600949"></p><p>通常，我们以 T+1 的周期调度 Hive SQL 脚本，在 Hive 数仓中进行分层处理，并最终产出离线指标和数据集市表供业务使用。</p><p>Hive 虽然对计算层做了很多优化，但是并没有改变 MapReduce 基于磁盘进行数据计算这一本质，因此还是存在严重的性能问题。在这种情况下，一个新的离线计算框架出现了，它就是 Spark。</p><p>2009 年，Spark 诞生于伯克利大学 AMP Lab 的一个研究性项目。</p><p>2010 年，Spark 正式开源，并于 2014 年成为 Aparch 基金会的顶级项目，整个过程不到五年时间。</p><p>和 MapReduce 相比，Spark 具有很多优势：</p><ul><li>实现了高效的 DAG 执行引擎，引入了对内存的使用。和 MapReduce 相比，Spark 基于内存的运算要快 100 倍以上，而基于硬盘的运算也要快 10 倍以上。</li><li>支持 Java、Python 和 Scala 的 API，支持 Spark SQL，给不同语言的开发者提供了更多选择。</li><li>丰富的生态，支持几十种上下游存储系统，支持近百种机器学习算法。</li><li>抽象出了 RDD（弹性分布式数据集）这一概念，支持迭代式计算，大幅提升了机器学习模型的训练速度。</li></ul><p>在之后的几年时间里，Spark + Hive  的离线数仓架构逐渐成熟，时至今日仍然是构建离线数仓的一种主流解决方案。</p><h1 id="实时架构的兴起"><a href="#实时架构的兴起" class="headerlink" title="实时架构的兴起"></a>实时架构的兴起</h1><h2 id="Flink实时计算引擎"><a href="#Flink实时计算引擎" class="headerlink" title="Flink实时计算引擎"></a>Flink实时计算引擎</h2><p>Hadoop 体系的离线批处理架构天然具有数据延迟的问题，无论是 MapReduce、Hive 还是 Spark，都无法满足互联网时代快速获取最新数据的需求，比如电商双 11 大屏的实时销售额展示。因此，相继出现了 Storm、Spark Streaming、Flink 这三个实时计算引擎，它们的对比如下：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225173750454.png" alt="image-20240225173750454"></p><p>Spark 本身是一个离线计算引擎，通过微批处理（Micro batch）实现对实时计算的支持。和 Storm、Flink 这两个专为实时计算而生的引擎相比，Spark 的延迟较高。在早期，大部分实时任务都是基于 Storm 开发的。Flink 开源后，它先进的设计理念和一些关键能力，比如状态管理、容错机制、精确一次处理、毫秒级延迟等，加上 Flink SQL、Flink CDC、Flink ML 等生态的建设以及背后商业化公司阿里巴巴的大量资源支持，在短短几年的时间内就成为了实时计算领域的事实标准。有了 Flink，建设端到端秒级延迟的实时数仓成为了可能。</p><h2 id="早期的实时数仓架构"><a href="#早期的实时数仓架构" class="headerlink" title="早期的实时数仓架构"></a>早期的实时数仓架构</h2><p>Flink 解决了计算层的延迟问题，但是实际上用户需要的是端到端的时效性。在存储层，我们需要选择一种低延迟的存储介质替换掉 Hive。实践中，Kafka 作为主流的分布式流平台，无论是吞吐量还是延迟都非常优秀，因此基于 Flink +  Kafka 的实时数仓架构很快流行起来。</p><p>在这个架构中，我们通过 ETL 工具将原始数据传输到 Kafka 中，形成 <a href="https://www.cnblogs.com/amyzhu/p/13513425.html">ODS</a> 层，并使用 Flink 进行分层处理。为了加快处理速度，DIM 层的维度数据通常是存在 Redis、HBase 等高性能 KV 库中的，基于 Flink 的多流 Join 能力进行打宽。为了提升查询的速度，最终的指标数据存储到基于 OLAP 引擎的 ADS 层，供用户使用。</p><p>Flink +  Kafka 的实时数仓架构，只能提供非常短时间内的数据。通常来说，ODS 层 Topic 的存储周期可能是七天或者是更短。因此更长时间跨度的指标，还是基于离线数仓的数据产出。这种离线数仓和实时数仓割裂的架构很快就遇到了结果不一致的问题：如果一个用户日活量指标，实时数仓产出的是 1 亿，离线数仓产出的是 1 亿 5 千万，业务该采用哪个呢？实际情况中，实时数仓可能只统计了主站的日活，而离线数仓把一些生态的日活也统计进去了，这就是口径不一致的问题。考虑到实时数仓和离线数仓通常是两个独立的团队，这一问题很难避免。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225174558385.png" alt="image-20240225174558385"></p><p>同时，实时计算的资源消耗显著大于离线计算，这种离线 + 实时数仓共存的架构，会导致大数据相关的成本倍数级增长，中小型公司很难接受。</p><p>为了解决实时和离线不一致、资源消耗大的问题，业界分别设计出了 Lamdba 和 Kappa 两种架构，以及基于这两种架构的一些变种。今天，我们在市面上所能看到的数仓架构，大部分都是在 Lamdba 和 Kappa 两种架构的基础上，根据业务诉求改良而来的。</p><h2 id="Lamdba-架构"><a href="#Lamdba-架构" class="headerlink" title="Lamdba 架构"></a>Lamdba 架构</h2><p>Lambda 架构由 Twitter 工程师 Nathan Marz 提出，是一种经典的、实施广泛的技术架构。它打通了原先割裂的实时和离线体系，通过提供给用户一个统一的视图，解决了实时和离线结果不一致的问题。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225174706512.png" alt="image-20240225174706512"></p><p>Lambda 架构由批处理层（Batch Layer）、速度处理层（Speed Layer）和用于响应查询的服务层（Serving Layer）组成。</p><ol><li>批处理层（Batch Layer）：负责存储和管理主数据集以及预先批处理计算好的视图。它使用可处理大量数据的分布式处理系统预先计算结果。通过处理所有的历史数据，这一层能够确保数据的准确性，并修复历史错误，然后更新现有的数据视图。</li><li>速度处理层（Speed Layer）：负责实时处理新来的大数据。它通过提供最新数据的实时视图来最小化延迟。当同样的数据在批处理层处理完成后，在速度层的数据就可以被替代掉了。这一层弥补了批处理层所导致的数据视图滞后。</li><li>服务层（Serving Layer）：负责响应查询。它从批处理层和速度处理层获取预先计算好的结果或者实时计算的数据视图，然后返回给用户。</li></ol><p>Lambda 架构的优缺点如下：</p><ul><li>优点：<ul><li>极高的稳定性，发生问题时可以直接通过离线链路补回数据，实时链路消费最新的数据即可。</li><li>保留了实时和离线两条链路，可以支持复杂的数据处理和分析。</li></ul></li><li>缺点：<ul><li>通过引入服务层来统一实时和离线结果不一致的问题，只是对用户来说统一了查询，没有从根本上解决问题。对于开发人员来说，还是要维护两条链路，并且还要额外维护一个服务层，增加了系统复杂度。</li><li>资源开销大，成本问题仍然存在。</li></ul></li></ul><h2 id="Kappa-架构"><a href="#Kappa-架构" class="headerlink" title="Kappa 架构"></a>Kappa 架构</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225174841218.png" alt="image-20240225174841218"></p><p>为了解决 Lamdba 架构过于复杂的问题，LinkedIn 公司的 Jay Kreps 结合实际经验与个人思考提出了 Kappa 架构。</p><p>Kappa 架构的核心是通过改进实时链路中计算、存储的部分来解决全量的问题，使得流处理和批处理可以共用一套代码。Kappa 架构认为对于历史数据的重复计算几率是很小的，即使需要，可以通过启用不同的实例的方式来做重复计算。</p><p>具体改进的地方包括：</p><ul><li>用 Kafka 等支持重放的消息队列系统收集各种各样的数据，需要几天的数据量就保存几天。</li><li>当需要全量重新计算时，重新起一个流计算实例，从头开始读取数据进行处理，并输出到一个新的结果存储中。</li><li>当新的实例做完后，停止老的流计算实例，并把一些老的结果删除。</li></ul><p>Kappa 架构 与 Lambda 架构相比，其优缺点是：</p><ul><li>优点：<ul><li>只需维护一套代码，开发、维护成本低。</li></ul></li><li>缺点：<ul><li>无法支持长时间跨度的数据处理。</li><li>一旦发生故障，重新计算的效率低。</li><li>流处理作业难以调试，出问题的概率高，对研发人员、运维人员的技术水平要求高。</li></ul></li></ul><p>Lambda 和 Kappa 都属于实时架构，因此都可以满足业务对实时性的要求，同时在资源成本、重计算成本、运维成本方面各有一些 trade-off。为了优化这两种架构的缺陷部分对业务的影响，诞生了一些改良后的版本，例如 Lambda+、Kappa+。同时，各大互联网公司也都有更贴合自家业务的魔改版。</p><p>但是，无论在 Lambda 和 Kappa 的基础上怎么改，实时和离线无法统一的根本问题始终没有得到解决。而在可预见的时间内，实时计算在大规模数据处理、机器学习等场景下无法完全取代离线计算，只能是互补的关系。在这种背景下，能够统一实时和离线的流批一体架构被寄予希望。</p><p>从上面的讲述中我们知道，Lambda 架构实现了流批一体的服务层，使得用户的体验是统一的，但是计算层和存储层仍然是割裂的。而 Kappa 架构下的批处理局限性很大。如果说我们能够吸收 Lambda 架构的理念，并且做到计算层和存储层的流批一体，那么问题是不是就得到解决了呢？</p><p>下面讲一讲如何实现流批一体的计算和存储。</p><h2 id="流批一体计算"><a href="#流批一体计算" class="headerlink" title="流批一体计算"></a>流批一体计算</h2><p>流批一体计算是指在大数据处理领域中，将流处理（Streaming）和批处理（Batch）结合在一起，使得同一套计算逻辑能够同时应用于两种处理模式，使得计算过程更加简洁和高效，并在最终结果上保持一致。</p><p>在 5.1 章节，我们已经讲过，Flink 是一个开源的实时计算引擎。虽然在 Flink 的早期版本中，对批处理也有一定程度的支持，但是总的来说，和 Spark 对比起来，Spark 批强流弱，Flink  流强批弱，二者无法独占分布式计算市场。</p><p>为了支持流批一体，Flink 做了以下几点改造：</p><ul><li>2015 年，阿里巴巴对 Spark 和 Flink 做了大量调研，认为 Flink Streaming 的概念优于 Spark Micro Batch 的概念。之后，阿里巴巴重投入大量人力开发基于 Flink 的内部版本 Blink，在 Flink DataStream、DataSet 底层 API 的基础上，强化了对 SQL 和 Table API 的支持，并在 2019 年将 Blink 的实现捐献给 到 Flink 社区。经过社区几个大版本的迭代，DataStream API 可以同时支持流和批，DataSet API 退出了历史舞台，Flink 终于能够提供统一的流批一体语义。</li></ul><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225175210216.png" alt="image-20240225175210216"></p><ul><li>推出子项目 Flink CDC，借助于 Flink SQL 和 DataStream API 强大的流批一体语义，在数据集成环节实现流批一体。</li><li>推出 Flink Batch 模式，用户只需要配置一个 Mode 即可自由实现批和流的切换。在性能上，实现了自适应批处理调度器、动态分区裁剪、推测执行、混合 Shuffle 等，能够提供不弱于 Spark 的批处理能力。</li><li>推出 Flink Catalog，强化对离线数仓生态的支持。</li></ul><p>在计算层，Flink 实现了流和批的统一，我们还需要让存储层支持流批一体，而无论是离线的 Hive 还是实时的 Kafka，都难以做到，因此需要新的存储系统来解决这个问题。目前，主要有两种主流存储架构可以提供流批一体：流式数据湖和统一实时数仓，下面我们分别讲一讲。</p><h2 id="流批一体存储"><a href="#流批一体存储" class="headerlink" title="流批一体存储"></a>流批一体存储</h2><h3 id="流式数据湖架构"><a href="#流式数据湖架构" class="headerlink" title="流式数据湖架构"></a>流式数据湖架构</h3><p>数据湖这个概念出现于2010年，旨在解决传统数据仓库和数据集市所面临的两大难题。首先，它希望通过统一的元数据存储来解决数据集市之间的数据孤岛问题，让所有数据都能够相互连接和共享。其次，数据湖还希望存储原始数据，包括结构化、半结构化和非结构化数据，而不是存储经过裁剪后的数据集市，以确保不会丢失数据的原始信息。</p><p>数据湖主要经历了四个发展阶段：</p><ol><li>早期，数据湖直接构建于 HDFS 之上，主要应用于机器学习所需要的大规模数据存储。由于缺乏有效的元数据管理，人们很难从中提取出有价值的信息。缺乏维护、管理的数据湖，随着大量低价值密度数据的涌入，会很快退化为数据沼泽，难以支持 BI（商业智能）业务。</li><li>随着云计算的发展， 2015 年，各个云厂商推出了基于对象存储（OSS）的云产品。对象存储具有大规模、高可用和低成本的优势，逐步替代了 HDFS 成为云上统一存储的主流选择。</li><li>2019 年前后，随着 Databricks、Uber 等公司陆续推出被称为数据湖三剑客的 Delta Lake、Hudi 和 Iceberg 湖格式，数据湖得到了广泛的应用。通过在数据湖的原始数据之上再构建一层元数据层、索引层的方式，解决了数据湖上数据的可靠性、一致性和性能等问题。</li><li>2020 年，以数据湖三剑客为代表的湖格式，生态建立在 Hadoop 和 Spark 的基础上，对批处理的支持较好。2022 年，随着 Paimon、Hudi 等湖格式支持 Changelog，并加强 Flink 的生态建设，数据湖内的数据可以实时流动起来，流式数据湖的概念推广起来。</li></ol><p>数据湖的特性包括：</p><ul><li>ACID 事务：同一张表经常会同时有多个工作流来读写，事务保证了我们能够读、写到正确的数据。</li><li>Schema Evolution：允许修改表的字段信息（如增删字段，修改字段类型和描述等）。</li><li>支持结构 &#x2F; 非结构数据，支持多类 API：湖仓架构能够支持半 &#x2F; 非结构化数据（如 JSON，图像，语音等）的存储，以及提供除了基本 SQL 之外丰富的 API 来处理数据，应用在如机器学习等场景。</li><li>流批一体：用数据湖架构替代 Lambda 架构，能够有效的简化流式和离线两条数据链路的开发和运维成本。</li><li>采用 ELT（提取 - 加载 - 转换）过程，而不是传统数仓的 ETL（提取 - 转换 - 加载）过程。</li><li>存算分离：存储和计算可以按需伸缩，并且使用廉价的 OSS、HDFS、MinIO 等存储介质，降低整体成本。</li></ul><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image.png" alt="image"></p><p>在国内，Hudi 和 Iceberg 的使用更多一点，Paimon 作为 Flink 的生态项目，对 Flink 的支持更完善，目前还处于追赶阶段。</p><p>﻿</p><p>下面是一个基于 Hudi 的流式数据湖架构。它与 Kappa 架构很像，区别只是在于用 Hudi 替换了 Kafka 作为存储介质，以提供流批一体的存储能力，同时支持流读流写、批读批写。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225180607633.png" alt="image-20240225180607633"></p><p>上面介绍的流式数据湖架构因为底层还是 HDFS，在分析能力和数据入湖速度上都是较慢的：</p><ul><li>虽然号称是流式数据湖，但通常还是使用批的方式进行导入，以降低底层小文件合并的压力，整体延迟比实时数仓高。</li><li>Hudi 分析能力差，需要额外引入 Trino、Spark 等查询引擎，加上数据湖本身就是建立在 Hadoop 之上的，还要维护一个 Hadoop 集群，架构上更加复杂了。Paimon 虽然可以提供高性能的单表查询能力，一旦多表关联查询性能就会大幅下降。</li></ul><p>有没有更简单的架构可以支持存储、计算、分析的流批一体呢？</p><h3 id="统一数仓架构"><a href="#统一数仓架构" class="headerlink" title="统一数仓架构"></a>统一数仓架构</h3><p>2016 年后，随着 Clickhouse 和 Doris 这两款性能极其强大的 MPP 数据库的开源，基于 Clickhouse 和 Doris 的实时数仓架构快速取代了基于 Kafka 的实时数仓架构。以 Doris 为例，主要有以下几大优势：</p><ol><li>高性能的数据存储和数据分析能力，多表关联查询能力突出。</li><li>数据全量存储，可以基于任意时间节点进行数据回溯。</li><li>数仓自身即可实现数据集成和数据分层，存储、计算、分析一体，极简架构，运维成本低。</li><li>支持 Flink CDC 的流批一体写入，也支持 Kafka 流写入或 MySQL、HDFS 批写入。</li><li>支持联邦查询和数据湖加速。</li></ol><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image%20%281%29.png" alt="image (1)"></p><p>上图可以看到，基于 Doris 的数仓架构链路短、组件少，简单易用，因此又称这种架构为统一数仓架构。这么简单的架构，Doris 是怎么实现流批一体的呢？</p><p>首先，在流处理环节：</p><ul><li>存储层：Doris 借助于 Flink Connector 可以实现毫秒级的数据更新和表结构变更。</li><li>计算层：Doris基于 Unique、Aggregate 和 Duplicate 数据模型，加上物化视图等能力，可以实现毫秒级数据分层，或者微批调度实现分钟级数据分层。</li><li>分析层：Doris 可以实现毫秒级多表关联查询。</li></ul><p>在批处理环节：</p><ul><li>存储层：Doris 通过 Broker 组件可以实现大批量的离线数据导入导出。</li><li>计算层：通过周期性调度实现数据处理和分层。</li><li>分析层：Doris 本身的分析能力可以支持离线场景下的分析，也可以导出到外部系统进行分析，产出离线指标。</li></ul><p>因此在存储、计算、分析等环节，Doris 都是流批一体的。</p><p><strong>那么基于 Doris 的统一实时数仓架构有没有什么问题呢？</strong></p><p>主要还是实时数仓本身的一些固有问题：</p><ol><li><p>首先，是实时数仓分层困难、上层数据不准的问题。实时数仓能够支持的业务复杂度和数据模型的复杂度都是有限的，并且层数多了后，延迟和数据不准确也会增加。因此在实践中，不建议分太多层。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image%20%282%29.png" alt="image (2)"></p></li><li><p>Doris 的存储主要使用 SSD，存储成本比较高。</p></li><li><p>Doris 不支持 Binlog 和 Changelog，因此不支持流读和时间旅行（数据多版本），数据一旦被更新，旧的数据就丢失了。</p></li><li><p>Doris 对非架构化数据、半结构化数据的支持不佳。</p></li></ol><p>以上的一些问题，很多已经列入了 Doris 2023 年的 Roadmap，在未来发展规划上，Doris 将借鉴数据湖的优秀特性，同时继续强化已有的数仓能力。正在开发中的一些关键能力包括：</p><ol><li>在已有的冷热分层功能的基础上，推出存算分离架构，大幅降低 Doris 集群的成本，用户可以在成本和性能上自主权衡。</li><li>实现 Changelog 和数据版本功能，在此基础上可以实现流读、消息订阅、时间旅行等，成为类似于 Paimon、Hudi 流式数据湖一样的流式数仓。</li><li>实现多表物化视图，在此基础上，实时数仓分层又多了一个新的选择。之前，单表的物化视图大部分情况下只能提供DWD层的分层。多表物化视图可以实现更高级别的分层，不再依赖调度系统进行微批处理，架构上更加统一了。</li><li>提升数据湖分析能力，增强对非结构化和半结构化数据的支持。</li><li>增强对高并发数据服务的支持，在中小规模业务场景下，Doris 可以直接对外提供数据服务，不再需要通过 KV 存储。</li></ol><p>未来，很期待 Doris 实现真正意义上的统一数仓，用 Doris 一个组件就可以实现实时数仓的搭建，成为中国的 Snowflake。</p><h1 id="新一代湖仓架构"><a href="#新一代湖仓架构" class="headerlink" title="新一代湖仓架构"></a>新一代湖仓架构</h1><p>最后，让我们展望一下未来几年湖仓架构发展的趋势。</p><h2 id="湖仓一体"><a href="#湖仓一体" class="headerlink" title="湖仓一体"></a>湖仓一体</h2><p>数据湖和数据仓库技术发展了二十年，各有优劣，谁也难以统一谁。在大型公司，通常数据湖、离线数据仓库，实时数据仓库都是要共同建设的，以满足不同业务线的需求。因此，湖仓一体这种湖和仓互相补充，协同工作的架构，在这几年被广泛推广。</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225181318311.png" alt="image-20240225181318311"></p><p>湖仓一体，简单来说，就是将数据湖的数据和数仓的数据从架构上互相打通，数据以低成本在湖和仓之间流动。</p><p>对于如何实现湖仓一体架构，有很多种实现，包括：</p><ol><li>湖上建仓：数据先全量存储到数据湖中，再将湖中的数据清洗后存储到数据仓库中，在数仓中进行数据建模、数据分层、元数据管理。</li><li>湖内建仓：数据先全量存储到数据湖中，再将湖中的数据清洗后进行数据建模、数据分层、元数据管理。</li><li>仓上建湖：数据先存储到数据仓库中，再将仓中的数据存储到数据湖中。数据湖存储全量数据，数仓周期性清理历史数据，只保留近期的数据。</li><li>湖旁建仓：数据湖和数据仓库的数据来自不同数据源，但是可以互相访问和快速流通。MPP 类型的数据仓库可以对湖中的数据进行查询加速。</li></ol><p>以 Hudi、Paimon 为代表的流式数据湖架构，和以 Doris、Clickhouse 为代表的统一数仓架构，在这几年经历了快速的发展。数据仓库和数据湖的边界正在慢慢模糊，数据湖自身的治理能力、数据仓库延伸到外部存储的能力都在加强。相信在不远的将来，湖和仓会实现真实的融合。</p><h2 id="云原生湖仓"><a href="#云原生湖仓" class="headerlink" title="云原生湖仓"></a>云原生湖仓</h2><p>除了之前介绍的数据湖、数据仓库的开源产品之外，各大云厂商都在主推自己的云原生湖仓，例如 Snowflake、阿里的 Hologres、MaxCompute，字节的 LAS（基于 Hudi）等，这些云产品的典型特性包括免运维、弹性伸缩等，同时性能也非常强大，湖仓全面云原生化是一个大的趋势。</p><h2 id="流式湖仓"><a href="#流式湖仓" class="headerlink" title="流式湖仓"></a>流式湖仓</h2><p>基于 Streaming Lakehouse 理念，实现数仓不同层级之间的实时数据的高效流动，可以解决实时数仓分层问题。目前 Hudi、Paimon 先后提出了流式数据湖的概念，其他开源湖仓产品和云湖仓产品也在跟进。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到这里，相信你对大数据架构真的是非常感兴趣了！在本文最后，让我们回顾一下大数据架构整体的发展脉络：</p><p><strong>传统数仓架构 -&gt; 离线大数据架构（数仓 &#x2F; 数据湖） -&gt; Lambda 数仓架构 -&gt; Kappa 数仓架构 -&gt; 新一代实时数仓 &#x2F; 流式数据湖 -&gt; 湖仓一体 -&gt; 湖仓融合 -&gt; 云原生湖仓</strong></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.assets/image-20240225181508538.png" alt="image-20240225181508538"></p><p><strong>最后我想说的是：架构从来没有优劣之分，不要盲目选择最先进的技术架构，而是应当综合考虑业务核心诉求、人力和资源预算、团队技术栈、维护成本等多方面因素，仔细权衡后再做决定，并且随着业务的发展不断调整我们的架构。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大数据架构演进&quot;&gt;&lt;a href=&quot;#大数据架构演进&quot; class=&quot;headerlink&quot; title=&quot;大数据架构演进&quot;&gt;&lt;/a&gt;大数据架构演进&lt;/h1&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背</summary>
      
    
    
    
    
    <category term="大数据" scheme="https://linjz.netlify.app/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>如何创建2个线程交替打印从1到100的数</title>
    <link href="https://linjz.netlify.app/2023/11/04/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA2%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0100%E7%9A%84%E6%95%B0/"/>
    <id>https://linjz.netlify.app/2023/11/04/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA2%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0100%E7%9A%84%E6%95%B0/</id>
    <published>2023-11-04T09:28:25.000Z</published>
    <updated>2023-11-04T09:47:14.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何创建2个线程交替打印从1到100的数"><a href="#如何创建2个线程交替打印从1到100的数" class="headerlink" title="如何创建2个线程交替打印从1到100的数"></a>如何创建2个线程交替打印从1到100的数</h1><p>我们可以创建两个线程，一个线程打印奇数，一个线程打印偶数，这样就是交替打印了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gdut.linjz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlternatePrint</span> &#123;</span><br><span class="line"><span class="comment">// 对象锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个类中实现两个线程交替打印数字1到100</span></span><br><span class="line">    <span class="comment">// 我们用线程池来创建线程，这是开启线程常用的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程池来创建线程，2个主线程，0个救急线程，救急线程存活时间0秒，阻塞队列长度为2，直接丢弃任务的拒绝政策</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                r-&gt;<span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;myThread&quot;</span>+c.getAndIncrement()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 提交两个任务</span></span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">task1</span>());</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">task2</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">task1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line"><span class="comment">// task1打印奇数，如果当前是偶数，则等待</span></span><br><span class="line"><span class="comment">// 这里使用循环是为了防止虚假唤醒，但其实在这道题是没什么问题的，用if或者while都是一样的，因为只有两个线程，当线程1被唤醒的时候就必然是满足条件的时候，当多个线程就不一定了，被唤醒了不一定满足条件，可能还需要再等待，所以使用while，这里主要是要养成好习惯，直接用while</span></span><br><span class="line">                    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;打印&quot;</span>+num++);</span><br><span class="line">                  <span class="comment">// 释放锁之前唤醒等待的线程</span></span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">task2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line"><span class="comment">// task2打印偶数，如果当前是奇数，则等待</span></span><br><span class="line"><span class="comment">// 这里使用循环是为了防止虚假唤醒</span></span><br><span class="line">                    <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;打印&quot;</span>+num++);</span><br><span class="line">                  <span class="comment">// 释放锁之前唤醒等待的线程</span></span><br><span class="line">                    LOCK.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><p>说一下Java如何创建线程，创建线程的4种方式</p><h2 id="方式一-继承Thread类"><a href="#方式一-继承Thread类" class="headerlink" title="方式一 继承Thread类"></a>方式一 继承Thread类</h2><p>继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　 System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//创建两个线程，用start启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();  </span><br></pre></td></tr></table></figure><h2 id="方式二-实现Runnable接口"><a href="#方式二-实现Runnable接口" class="headerlink" title="方式二 实现Runnable接口"></a>方式二 实现Runnable接口</h2><p>实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target，也可以用匿名内部类的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　  System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//先创建一个Task类，然后把类传给线程类Thread，创建线程成功</span></span><br><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();  </span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);  </span><br><span class="line">thread.start(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名内部类的方式</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>));</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h2 id="方式三-实现Callable接口"><a href="#方式三-实现Callable接口" class="headerlink" title="方式三 实现Callable接口"></a>方式三 实现Callable接口</h2><p>实现Callable接口，重写call方法，得指定返回值的类型，这种方式支持拿到线程运行结束的返回值，接着，实现Callable接口的实现类的实例对象作为FutureTask构造函数的target，这个FutureTask的泛型类型与前面设置的返回类型一致，可以通过这个FutureTask实例对象拿到线程运行结束的返回值，然后这个FutureTask实例对象作为Thread构造函数的target。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 创建MyCallable对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">      <span class="comment">// 创建FutureTask对象，把mc作为其构造函数的target</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">      <span class="comment">// 创建Thread对象，把ft作为其构造函数的target</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">      <span class="comment">// 调用start方法启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">      <span class="comment">// 调用ft的get方法获取线程运行结束结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里稍微插一段</p><h3 id="Runnable接口和Callable接口有什么区别？"><a href="#Runnable接口和Callable接口有什么区别？" class="headerlink" title="Runnable接口和Callable接口有什么区别？"></a>Runnable接口和Callable接口有什么区别？</h3><p>1.Runnable接口的run方法没有返回值；</p><p>2.Callable接口的call方法有返回值，是个泛型，和FutureTask配合可以用来获取执行的结果；</p><p>3.Callable接口的call方法允许抛出异常；而Runnable接口的run方法的异常只能在内部消化，不能继续上抛；（实现Runnable接口的run方法不能抛异常是因为Runnable接口的run方法本身没有抛异常，实现类实现接口，方法重写，子类只能抛出与父类相等或小的异常，而Callable接口的call方法本身有抛异常）</p><h3 id="线程的run方法和start方法有什么区别？"><a href="#线程的run方法和start方法有什么区别？" class="headerlink" title="线程的run方法和start方法有什么区别？"></a>线程的run方法和start方法有什么区别？</h3><p>start()：用来启动线程，通过该线程调用run方法执行run方法中定义的逻辑代码，start方法只能被调用一次。</p><p>run()：封装了要被线程执行的代码，可以被调用多次，idea会提示开启线程调用start方法而不是run方法</p><h2 id="方式四-创建线程池"><a href="#方式四-创建线程池" class="headerlink" title="方式四 创建线程池"></a>方式四 创建线程池</h2><p>创建线程池是在项目中创建线程使用最多的方式</p><h3 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231029221025025.png" alt="image-20231029221025025"></p><h3 id="线程池的执行原理"><a href="#线程池的执行原理" class="headerlink" title="线程池的执行原理"></a>线程池的执行原理</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231029221304768.png" alt="image-20231029221304768"></p><p>四种拒绝策略：</p><p>1.直接抛异常</p><p>2.用调用者所在线程执行任务</p><p>3.丢弃阻塞队列中最靠前的任务，执行当前任务</p><p>4.直接丢弃任务</p><h3 id="线程池常见的阻塞队列"><a href="#线程池常见的阻塞队列" class="headerlink" title="线程池常见的阻塞队列"></a>线程池常见的阻塞队列</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231030102152802.png" alt="image-20231030102152802"></p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231030102642183.png" alt="image-20231030102642183"></p><p>一般使用LinkedBlockingQueue，因为锁的粒度更小，并发能力更强，不过记得初始化其大小，否则就是无限大小的</p><h3 id="确定核心线程数"><a href="#确定核心线程数" class="headerlink" title="确定核心线程数"></a>确定核心线程数</h3><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231030103511395.png" alt="image-20231030103511395"></p><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">            r-&gt;<span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;myThread&quot;</span>+c.getAndIncrement()),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line">  <span class="comment">// 提交两个任务</span></span><br><span class="line">    threadPool.submit(()-&gt;System.out.println(Thread.currentThread().getName()));</span><br><span class="line">    threadPool.submit(()-&gt;System.out.println(Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100/%E5%BE%85%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20231104171959189.png" alt="image-20231104171959189"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何创建2个线程交替打印从1到100的数&quot;&gt;&lt;a href=&quot;#如何创建2个线程交替打印从1到100的数&quot; class=&quot;headerlink&quot; title=&quot;如何创建2个线程交替打印从1到100的数&quot;&gt;&lt;/a&gt;如何创建2个线程交替打印从1到100的数&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="JUC" scheme="https://linjz.netlify.app/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>反转链表的n种考法</title>
    <link href="https://linjz.netlify.app/2023/10/18/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84n%E7%A7%8D%E8%80%83%E6%B3%95/"/>
    <id>https://linjz.netlify.app/2023/10/18/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84n%E7%A7%8D%E8%80%83%E6%B3%95/</id>
    <published>2023-10-18T11:54:55.000Z</published>
    <updated>2023-10-19T11:47:45.790Z</updated>
    
    <content type="html"><![CDATA[<p>反转链表我目前接触到有几种考法，写篇文章总结记录一下：</p><h2 id="反转整条链表"><a href="#反转整条链表" class="headerlink" title="反转整条链表"></a>反转整条链表</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/Snipaste_2023-10-18_20-22-41.png" alt="反转链表"></p><p>本题目有迭代和递归两种方法实现</p><h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">// 迭代的方式使用两个指针和一个辅助指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 当只有一个结点的时候，head不为null不需要反转直接返回head，当head为null的时候返回null，所以我们可以写一起，直接返回head，这样head为null返回head其实也是返回null，head不为null刚好返回head</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 接下来是递归方式，递归方式很神奇的，很奇妙</span></span><br><span class="line">        <span class="comment">// 递归先写递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 注意是return head而不是null，因为当到了最后一个结点的时候，不需要反转，此时head不是null，head.next是null，如果返回null就把最后一个结点给抛弃掉了，当head为null的时候返回null和返回head是一样的，区别就在于当head不是null的时候</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 仔细看就会知道每一层的这个last都是一样的，就是最后一个结点，只是我们需要不断传递上去而已</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转前n个结点"><a href="#反转前n个结点" class="headerlink" title="反转前n个结点"></a>反转前n个结点</h2><p>反转前n个结点其实就是在反转整条链表的基础上做一些小小的修改而已，同样有迭代和递归实现</p><h3 id="迭代实现-1"><a href="#迭代实现-1" class="headerlink" title="迭代实现"></a>迭代实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 需要先找到第n+1个结点</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n || node != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">        node = node.next;            </span><br><span class="line">&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">      <span class="comment">// 修改一下循环的条件</span></span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 把第n+1个结点及后边的结点接上</span></span><br><span class="line">      head.next = node;</span><br><span class="line">      <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">// 需要一个全局变量来接住第n+1个结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归先写递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">          node = head.next;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next, n - <span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转从left到right区间的结点"><a href="#反转从left到right区间的结点" class="headerlink" title="反转从left到right区间的结点"></a>反转从left到right区间的结点</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/Snipaste_2023-10-18_21-08-34.png" alt="反转从m到n的结点"></p><p>反转从left到right区间的结点就是在反转前n个结点的基础上再做一些修改而已</p><h3 id="修改迭代版"><a href="#修改迭代版" class="headerlink" title="修改迭代版"></a>修改迭代版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="comment">// 这道题是反转从1到n的链表的升级版，升级为反转从left到right的部分区间链表，我们只需要在反转1到n的基础上进行一些修改就可以了，修改递归版和修改迭代版都可以的，这里先修改迭代版</span></span><br><span class="line"><span class="comment">// 如果left等于1，那不就正好是我们想要的从1到n嘛，不为1怎么办，那就想办法让它等于1，也就是不断逻辑改变头结点直到left为1，我们可以递归下去不断改变头结点，不过注意，这样left和right也得不断跟着改变</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 需要先找到第n+1个结点</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n || node != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">        node = node.next;            </span><br><span class="line">&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">      <span class="comment">// 修改一下循环的条件</span></span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 把第n+1个结点及后边的结点接上</span></span><br><span class="line">      head.next = node;</span><br><span class="line">      <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改递归版"><a href="#修改递归版" class="headerlink" title="修改递归版"></a>修改递归版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录第n+1的结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="comment">// 反转前n个结点，那么第n+1后面的结点就不能动，那么我们得找出第n+1的结点，且得给它记录一下，因为反转后的头结点需要指向第n+1的这个结点，毕竟后面一段不能给它丢了，而且我们使用的是递归的方式解决，所以要使用一个全局变量来记录</span></span><br><span class="line">        <span class="comment">// 递归先写递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">          node = head.next;</span><br><span class="line">          <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n-<span class="number">1</span>);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="每k个结点反转"><a href="#每k个结点反转" class="headerlink" title="每k个结点反转"></a>每k个结点反转</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/Snipaste_2023-10-18_21-27-23.png" alt="每k个结点反转"></p><p>这道题也可以是在反转前n个结点的基础上进行一些修改就行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="comment">// 每k个反转一次，那么第一次就是前k个结点反转，接着我们可以让第k+1个结点成为第一个结点，那么不就又是前k个结点反转了吗，只要我们把反转后的拼接起来就可以了</span></span><br><span class="line">      <span class="comment">// p为每一层的第k+1个结点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">// 递归出口，不足k个的保持原样</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(p == <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> head;</span><br><span class="line">           &#125;</span><br><span class="line">           p = p.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 反转前k个结点</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseKN(head,p);</span><br><span class="line">      <span class="comment">// head.next接的下一小段链表的新头结点</span></span><br><span class="line">       head.next = reverseKGroup(p,k);</span><br><span class="line">       <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseKN</span><span class="params">(ListNode head, ListNode node)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 这一步其实就没有必要了，因为head.next需要接的不是这个node，而是下一小段链表的新头结点，不是node这个旧头结点，当然写着也不影响，毕竟后面会接上新的头结点的，只是没有必要，但是请注意可以这么做的前提是reverseKGroup这个方法保存了node这个结点，至少得知道怎么找到node这个结点</span></span><br><span class="line">      <span class="comment">//  head.next = node;</span></span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="每2个结点反转"><a href="#每2个结点反转" class="headerlink" title="每2个结点反转"></a>每2个结点反转</h2><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/1.png" alt="每2个结点反转"></p><p>这道题，由于我先做的每k个结点反转，所以我一开始是根据每k个结点反转修改的，但是后面越做发现不用这么麻烦的，但是我这里还是把两种方法都写一下吧</p><h3 id="由每k个结点变形"><a href="#由每k个结点变形" class="headerlink" title="由每k个结点变形"></a>由每k个结点变形</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="comment">// 这道题其实就是之前做过的每k个结点进行反转，不过就是这里k固定为2就是了，所以把之前那道题目稍微改一下就行了，一样的，因为那道题目后面如果不满足k个结点就不管，而这里不满足2也就是只剩一个结点也是不做任何操作所以刚好</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseN(head,node);</span><br><span class="line">        head.next = swapPairs(node);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, ListNode node)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>, p2 = head;</span><br><span class="line">        <span class="keyword">while</span>(p2 != node)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;</span><br><span class="line">            p1 = p2;</span><br><span class="line">            p2 = p;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 这句可以不要了，和上面同理，同样的，得记住可以这么做的前提是调用这个方法的方法保存了node这个结点，至少可以找到这个结点，否则这里没了这一句，又没有保存node结点，就会把后面的链表给丢失了</span></span><br><span class="line">       <span class="comment">// head.next = node;</span></span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNext</span> <span class="operator">=</span> swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNext;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--10b77/</a></p><p><a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/ru-he-k-ge-d591d/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/ru-he-k-ge-d591d/</a></p><p><a href="https://www.programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">https://www.programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;反转链表我目前接触到有几种考法，写篇文章总结记录一下：&lt;/p&gt;
&lt;h2 id=&quot;反转整条链表&quot;&gt;&lt;a href=&quot;#反转整条链表&quot; class=&quot;headerlink&quot; title=&quot;反转整条链表&quot;&gt;&lt;/a&gt;反转整条链表&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://l</summary>
      
    
    
    
    
    <category term="算法" scheme="https://linjz.netlify.app/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>相交链表问题</title>
    <link href="https://linjz.netlify.app/2023/10/13/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://linjz.netlify.app/2023/10/13/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</id>
    <published>2023-10-13T13:07:21.000Z</published>
    <updated>2023-10-18T11:55:40.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h2><p>力扣第 160 题【相交链表】函数头如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span>;</span><br></pre></td></tr></table></figure><p>给你输入两个链表的头结点 <code>headA</code> 和 <code>headB</code>，这两个链表可能存在相交。</p><p>如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。</p><p>比如题目给我们举的例子，如果输入的两个链表如下图：</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/linjz/blog/4.png" alt="相交链表"></p><p>那么我们的算法应该返回 <code>c1</code> 这个节点。</p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><p>仅用内存为0（1），说明不可以使用外部存储，比如使用set先将A链表的节点存储起来，再用B的结点去判断的方法，只能想其他方法了，这里有三个方法可以试一下</p><hr><h3 id="第一种-逻辑拼接"><a href="#第一种-逻辑拼接" class="headerlink" title="第一种 逻辑拼接"></a>第一种 逻辑拼接</h3><p>第一种是比较奇妙的，反正我一开始是没看懂，但当我看明白的时候就豁然开朗，nice，真的很妙，逻辑拼接，让指针p1遍历A链表，遍历完接着遍历B链表，让指针p2遍历B链表，走完接着遍历A链表，这样到最后，p1和p2会在第一个相交结点相遇，为什么呢，就上边图的示例来看，c1，c2是公共的部分，p1会先走a1，a2然后走公共部分，p2会先走b1，b2，b3然后走公共部分，接着p1走B链表的部分，就是b1，b2，b3然后到c1，p2走A链表的部分，就是a1，a2，然后c1，注意看，这个时候，p1是走了A的a1，a2，B的b1，b2，b3和一次公共部分c1，c2，而p2也是走了A的a1，a2，B的b1，b2，b3和一次公共部分c1，c2，两者是同时出发的且每次都只走一步的，，那么他们下一步就是共同到达公共部分的第一个结点，也就是我们想要的那个结点,如果AB链表没有交点的话，那么就是共同走到null结点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">// p1走完A开始走B</span></span><br><span class="line">                p1 = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p2 == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">// p2走完B开始走A</span></span><br><span class="line">                p2 = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="第二种-调整起点使得到达结尾步数一致"><a href="#第二种-调整起点使得到达结尾步数一致" class="headerlink" title="第二种 调整起点使得到达结尾步数一致"></a>第二种 调整起点使得到达结尾步数一致</h3><p>接下来我们来看看方法二，方法二就好理解一些了，比方法一好很多，方法二是我们先算出AB各自的长度，我们的目的是让p1和p2同时走到一个结点上，由于AB链表的长度不一定相同，所以从各自头结点开始走的话，不一定能同时走到结尾，如果我们可以保证他们每一次都同时走到结尾那就可以判断了，因为这个链表相交，这是一个单链表，不是二叉树什么的，就是说一个结点只能指向另一个结点，不能同时指向多个结点，而一个结点却可以被多个结点同时指向，所以当两个链表有交点的时候，其后半段就是完全一样的，所以如果p1和p2能够同时到达结尾的话必然会同时在第一个交点相遇，如果没有那么也就是同时走到null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// 先算AB的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthA</span> <span class="operator">=</span> getLength(headA);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lengthB</span> <span class="operator">=</span> getLength(headB);</span><br><span class="line">    <span class="comment">// 算出长度后，比较一下哪一个长，长的那个对应的p结点就需要先走几步，使得两个p结点到达结尾的步数一致</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">        <span class="comment">// A链表长，那p1得先走lengthA-lengthB步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthA - lengthB; i++)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lengthA &lt; lengthB)&#123;</span><br><span class="line">        <span class="comment">// B链表长，那p2得先走lengthB-lengthA步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengthB - lengthA; i++)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得先判断，可能补完步数就正好是相交点</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 获取链表的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; p != <span class="literal">null</span>; p = p.next)&#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="第三种-物理连接成环"><a href="#第三种-物理连接成环" class="headerlink" title="第三种 物理连接成环"></a>第三种 物理连接成环</h3><p>第三种方法就非常有意思了，我们可以把A的尾结点连接B的结点，第一种方法是逻辑连接，我们第三种方法就是物理连接，不过得注意我们最后得还原成原样，题目也有这句话，在返回结果后，两个链表仍保持原有的结构。那么，这样的物理连接有什么用呢，我们可以想象，如果AB相交的话，那么这样连接就会形成一个环，且环的起点就是我们要找的相交点，那么这个问题就转变成了求是否存在环且求环的起点，注意这里其实还隐藏了一个问题，就是求A链表的倒数第一个结点，有点意思吧，这个简单的问题给我变成了三个问题，是否存在环，求环的起点，求倒数第n个结点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line"><span class="comment">// 先要求A的倒数第1个结点，找到那个结点才可以与B连接，如何求呢，双指针解决，先让一个指针从头结点出发走cnt步，接着再让一个指针从头结点与这个指针同时原地出发，等第一个指针走到表尾的时候，第二个指针就走到了倒数第cnt个，这是什么原理呢，假设表长尾l，第一个指针先走了cnt步，也就是停下的地方距离表尾null还有l-cnt步，所以等到第一个指针走到表尾null的时候，第二个指针就走了l-cnt步，由于是从表头1的位置开始走的，第二个指针停下的位置是l-cnt+1，要算上头结点的位置，这个l-cnt+1就是倒数第cnt的位置，为什么呢，可以这么看，总长度是l，然后从后面开始数cnt个，所以得减去cnt，接着起点是1，是从1开始算起的，所以l-cnt+1就是倒数第cnt的位置</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headA;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// p1停下来的时候，p2就是我们要找的A的尾结点</span></span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接着就是拼接AB链表</span></span><br><span class="line">        p2.next = headB;</span><br><span class="line">        <span class="comment">// 拼接好后我们就要判断是否有环以及求环的起点了，用快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明没有环，那就还原AB链表然后返回null</span></span><br><span class="line">            p2.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 存在环，那么如何找环起点呢，假设快慢指针第一次相遇的时候，slow走了k步，fast走了2k步，多出来的这k步就是绕环走的，且是环长度的整数倍，再假设从相遇点到环的起点有m步，那么从起点到环的起点就有k-m步，而巧的是从相遇点到环的起点也是k-m步，为什么呢，因为k是环长度的整数倍，而相遇点到环的起点有m步，那么从相遇点走k步会回到相遇点，那么我们不走完k步，我们留m步不走，就是k-m步，这样到达的点就会离相遇点有m步，这也就是环的起点，因为环的起点离相遇点就是m步，而我们又是在一个环中单向行驶的，所以这一路上走到的离相遇点有m步的点就是环起点</span></span><br><span class="line">        slow = headA;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上三种方法都没有循环套循环，时间复杂度都是O(n)，也没有使用数组集合等，空间复杂度是O(1)。</p><p>参考：<a href="https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/">https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两个链表是否相交&quot;&gt;&lt;a href=&quot;#两个链表是否相交&quot; class=&quot;headerlink&quot; title=&quot;两个链表是否相交&quot;&gt;&lt;/a&gt;两个链表是否相交&lt;/h2&gt;&lt;p&gt;力扣第 160 题【相交链表】函数头如下：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    
    <category term="算法" scheme="https://linjz.netlify.app/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue什么时候是大顶堆，什么时候是小顶堆</title>
    <link href="https://linjz.netlify.app/2023/10/12/PriorityQueue%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%A4%A7%E9%A1%B6%E5%A0%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%B0%8F%E9%A1%B6%E5%A0%86/"/>
    <id>https://linjz.netlify.app/2023/10/12/PriorityQueue%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%A4%A7%E9%A1%B6%E5%A0%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%98%AF%E5%B0%8F%E9%A1%B6%E5%A0%86/</id>
    <published>2023-10-12T12:22:10.000Z</published>
    <updated>2023-10-16T12:52:01.579Z</updated>
    
    <content type="html"><![CDATA[<p>在解lecode第23题：合并K个升序链表的时候，需要用到PriorityQueue小顶堆，每次从堆中取出最小的节点然后依次组成我们想要的链表，题解是用了Java库的中的优先级队列PriorityQueue</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(lists.length,(a,b)-&gt;(a.val - b.val));</span><br></pre></td></tr></table></figure><p>其中，这里的(a,b)-&gt;(a.val - b.val)是lambda表达式，实际上是int compare (Integer a, Integer b) { return a.val - b.val;  }</p><p>(a,b)-&gt;(a.val - b.val)到底是小顶堆还是大顶堆，怎么看呢，为什么a.val - b.val是小顶堆而b.val - a.val是大顶堆呢？</p><p><strong>由于源码中新入队元素x是在第1个参数a的位置，因此最大&#x2F;最小优先队列主要根据第1个参数的大小关系来判断</strong>。 (主要还是在于控制compare这个方法来控制大小顶堆)</p><ul><li><p>对于最小堆，当x&lt;e时，要想让x上升，即compare (x, e) &lt; 0，那就得让int compare (Integer x, Integer e) { return x &lt; e ? -1 : 1;  }</p></li><li><p>对于最大堆，当x&gt;e时，要想让x上升，即compare (x, e) &lt; 0，那就得让int compare (Integer x, Integer e) { return x &gt; e ? -1 : 1;  }</p></li></ul><p>至于为什么要让其返回负数呢？</p><p>源码是这么设计的</p><p><img src="https://linjz-blog.oss-cn-hangzhou.aliyuncs.com/1280X1280.PNG" alt="PriorityQueue大小堆决定源码"></p><p>所以，在这里，(a,b)-&gt;(a.val - b.val)，也就是int compare (Integer a, Integer b) { return a.val - b.val;  }，a.val &lt; b.val的时候，compare (x, e) &lt; 0，a小且a上升，是小顶堆。</p><p>反之，(a,b)-&gt;(b.val - a.val)，也就是int compare (Integer a, Integer b) { return b.val - a.val;  }，a.val &gt; b.val的时候，compare (x, e) &lt; 0，a大且a上升，是大顶堆。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在解lecode第23题：合并K个升序链表的时候，需要用到PriorityQueue小顶堆，每次从堆中取出最小的节点然后依次组成我们想要的链表，题解是用了Java库的中的优先级队列PriorityQueue&lt;/p&gt;
&lt;figure class=&quot;highlight java</summary>
      
    
    
    
    
    <category term="PriorityQueue" scheme="https://linjz.netlify.app/tags/PriorityQueue/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象基础知识回顾</title>
    <link href="https://linjz.netlify.app/2023/10/11/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <id>https://linjz.netlify.app/2023/10/11/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</id>
    <published>2023-10-11T11:07:51.000Z</published>
    <updated>2023-11-16T11:41:17.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>下面是一个求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案。</p><p><strong>面向过程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义圆的半径</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算圆的面积和周长</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> Math.PI * radius * radius;</span><br><span class="line">        <span class="type">double</span> <span class="variable">perimeter</span> <span class="operator">=</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出圆的面积和周长</span></span><br><span class="line">        System.out.println(<span class="string">&quot;圆的面积为：&quot;</span> + area);</span><br><span class="line">        System.out.println(<span class="string">&quot;圆的周长为：&quot;</span> + perimeter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面向对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="comment">// 定义圆的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算圆的面积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算圆的周长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPerimeter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个半径为3的圆</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出圆的面积和周长</span></span><br><span class="line">        System.out.println(<span class="string">&quot;圆的面积为：&quot;</span> + circle.getArea());</span><br><span class="line">        System.out.println(<span class="string">&quot;圆的周长为：&quot;</span> + circle.getPerimeter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，面向对象开发的程序一般更易维护、易复用、易扩展。</p><hr><h3 id="对象实体与对象引用"><a href="#对象实体与对象引用" class="headerlink" title="对象实体与对象引用"></a>对象实体与对象引用</h3><p>new 创建对象实例（对象实例在 内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><hr><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率.</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。（拥有父类没有的属性和方法）</li><li>子类可以用自己的方式实现父类的方法。(方法重写)</li></ol><hr><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><hr><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是<strong>所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><hr><h3 id="深拷贝，浅拷贝和引用拷贝"><a href="#深拷贝，浅拷贝和引用拷贝" class="headerlink" title="深拷贝，浅拷贝和引用拷贝"></a>深拷贝，浅拷贝和引用拷贝</h3><p>关于深拷贝和浅拷贝区别：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li></ul><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p><p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。(这是因为没有调用Address的clone方法，Person的clone方法只是调用super.clone()而已，所以Address还是同一个，故深拷贝就要连Address也一起复制，而不是共用同一个)</p><hr><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure><p>从输出结构就可以看出，显然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><hr><h4 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h4><p>引用拷贝就是两个不同的引用指向同一个对象。</p><hr><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><h4 id="为什么有hashCode"><a href="#为什么有hashCode" class="headerlink" title="为什么有hashCode"></a>为什么有hashCode</h4><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p><p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了<code>equals</code> 的次数，相应就大大提高了执行速度。</p><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><hr><h4 id="那为什么-JDK-还要同时提供hashCode-和-equals-这两个方法呢？"><a href="#那为什么-JDK-还要同时提供hashCode-和-equals-这两个方法呢？" class="headerlink" title="那为什么 JDK 还要同时提供hashCode() 和 equals()这两个方法呢？"></a>那为什么 JDK 还要同时提供<code>hashCode()</code> 和 <code>equals()</code>这两个方法呢？</h4><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h4 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a>那为什么不只提供 <code>hashCode()</code> 方法呢？</h4><p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p><hr><h4 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</h4><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><hr><h4 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong>：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p>就会出现一个值有多个位置的情况</p><p><strong>总结</strong>：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>但两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><hr><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><p><strong>可变性</strong></p><p><code>String</code> 是不可变的（后面会详细分析原因）。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><hr><h4 id="String为什么是不可变的？"><a href="#String为什么是不可变的？" class="headerlink" title="String为什么是不可变的？"></a>String为什么是不可变的？</h4><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<del>所以<code>String</code> 对象是不可变的。</del></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️修正：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况，只是不能再指向其他对象而已，并不是不能修改）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p>在 Java 9 之后，<code>String</code>、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p><hr><h4 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h4><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。(其他情况下的“+”是值相加，而String的“+”并不是地址值相加)</p><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。这个改进是 JDK9 的 <a href="https://openjdk.org/jeps/280">JEP 280open in new window</a> 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。</p><hr><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h4 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象?"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象?</h4><p>会创建 1 或 2 个字符串对象。</p><p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</p><p>示例代码（JDK 1.8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><p>示例代码（JDK 1.8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象“abc”的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="String的intern方法有什么用？"><a href="#String的intern方法有什么用？" class="headerlink" title="String的intern方法有什么用？"></a>String的intern方法有什么用？</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><p>示例代码（JDK 1.8） :</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>s3指向的是堆中新new出来的“Java”，并不是s1时在堆中创建的“Java”，但是注意常量池中保存的是指向s1时在堆中创建的“Java”的引用，即s1，所以s3.intern()返回的是常量池中“Java”对应的引用s1。</p><hr><h4 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h4><p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。所以这里比较的是地址值。</p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure><p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p><p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>被<code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h4><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong>Exception</strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><hr><h4 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。（必须处理否则无法通过编译）</p><p>常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><hr><h4 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h4><ul><li><p><code>String getMessage()</code>: 返回异常发生时的简要描述</p></li><li><p><code>String toString()</code>: 返回异常发生时的详细信息</p></li><li><p><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</p></li><li><p><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</p></li></ul><hr><h4 id="try-catch-finally-如何使用"><a href="#try-catch-finally-如何使用" class="headerlink" title="try-catch-finally 如何使用?"></a>try-catch-finally 如何使用?</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h4><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><hr><h4 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h4><ol><li><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p></li><li><p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行（catch和finally块不需要用到资源）</p></li></ol><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h4><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li><li>……</li></ul><hr><p>参考：</p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html">https://javaguide.cn/java/basis/java-basic-questions-02.html</a></p><p><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html">https://javaguide.cn/java/basis/java-basic-questions-03.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;h3 id=&quot;面向对象与面向过程&quot;&gt;&lt;a href=&quot;#面向对象与面向过程&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Java面向对象" scheme="https://linjz.netlify.app/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础概念与常识</title>
    <link href="https://linjz.netlify.app/2023/10/10/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
    <id>https://linjz.netlify.app/2023/10/10/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</id>
    <published>2023-10-10T13:55:31.000Z</published>
    <updated>2023-10-16T12:38:13.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础概念与常识"><a href="#Java基础概念与常识" class="headerlink" title="Java基础概念与常识"></a>Java基础概念与常识</h2><h3 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h3><ol><li><p>简单易学</p></li><li><p>面向对象（封装，继承，多态）</p></li><li><p>平台无关性（JVM实现平台无关性）</p></li><li><p>支持多线程（C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）</p><p>Java实现多线程的方式有：</p></li></ol><ul><li><p>继承Thread类，重写run方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　 System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//创建两个线程，用start启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">myThread1.start();  </span><br><span class="line">myThread2.start();  </span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target，可以用匿名内部类的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">OtherClass</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">　　  System.out.println(<span class="string">&quot;线程的run()方法&quot;</span>);  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//先创建一个MyThread类，然后把类传给线程类Thread，创建线程成功</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);  </span><br><span class="line">thread.start();  </span><br></pre></td></tr></table></figure></li><li><p>通过线程池创建线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;通过线程池方式创建的线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;POOL_NUM; i++) &#123;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="comment">// Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line">executorService.execute(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>异常处理和自动内存管理</li><li>编译与解释并存（先编译成.class文件再交给各对应操作系统的JVM解释执行）</li></ol><p>⚠️注意：实际上，跨平台已经不是Java最大的卖点了，目前市面上虚拟化技术已经非常成熟了，比如Docker就很容易实现跨平台，Java强大的生态才是真的值得关注的！</p><hr><h3 id="JDK-vs-JRE-vs-JVM"><a href="#JDK-vs-JRE-vs-JVM" class="headerlink" title="JDK vs JRE vs JVM"></a>JDK vs JRE vs JVM</h3><p>这三者是不断包含的关系，JDK包含JRE，JRE包含JVM。</p><p>JDK包括JRE和Java，Javadoc等工具</p><p>JRE包括JVM，Java基础类库</p><p>⚠️注意：如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。</p><hr><h3 id="JIT和AOT"><a href="#JIT和AOT" class="headerlink" title="JIT和AOT"></a>JIT和AOT</h3><p>有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>JDK 9 引入了一种新的编译模式 <strong>AOT(Ahead of Time Compilation)</strong> 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><h4 id="既然AOT-这么多优点，那为什么不全部使用这种编译方式呢？"><a href="#既然AOT-这么多优点，那为什么不全部使用这种编译方式呢？" class="headerlink" title="既然AOT 这么多优点，那为什么不全部使用这种编译方式呢？"></a>既然AOT 这么多优点，那为什么不全部使用这种编译方式呢？</h4><p>我们前面也对比过 JIT 与 AOT，两者各有优点，只能说 AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。（但也不是全部都是JIT来做，JIT只是一些热点代码，其余的还是一句一句解释执行的，所以是编译与解释并存）</p><hr><h3 id="Java与C"><a href="#Java与C" class="headerlink" title="Java与C++"></a>Java与C++</h3><ul><li><p>Java 不提供指针来直接访问内存，程序内存更加安全</p></li><li><p>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</p></li><li><p>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</p></li><li><p>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p></li></ul><hr><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java有8种基本数据类型：</p><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ul><p><strong>注意：</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><hr><h4 id="基本类型与包装类型"><a href="#基本类型与包装类型" class="headerlink" title="基本类型与包装类型"></a>基本类型与包装类型</h4><ul><li><p>用途：基本类型一般用于常量和局部变量，包装类型除了常量，局部变量，还有方法参数，对象属性，以及泛型。</p></li><li><p>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。（未被static修饰说明属于对象，对象是在堆中的，如果被static修饰说明属于类，存放在栈）一般成员变量应使用基本数据类型对应的包装类型；</p><p>包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。（这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存）</p></li><li><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p></li><li><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p></li><li><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p></li></ul><hr><h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>⚠️注意：所有的包装类对象之间值的比较，全部应该使用equals方法来比较，这是因为对于Integer var &#x3D; ? 在-128到127之间的赋值，Integer对象是在IntegerCache.cache产生的，会复用已有的对象，这个区间内的Integer值可以直接使用&#x3D;&#x3D;进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有的对象，这是一个大坑，推荐使用equals方法进行判断。</p><hr><h4 id="自动装箱与拆箱的原理"><a href="#自动装箱与拆箱的原理" class="headerlink" title="自动装箱与拆箱的原理"></a>自动装箱与拆箱的原理</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型</li></ul><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 应该使用 long 而不是 Long</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h4><p><strong>语法形式</strong>：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p><p><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p><p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</p><p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h4><ol><li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p></li><li><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p></li></ol><hr><h4 id="静态方法和实例方法"><a href="#静态方法和实例方法" class="headerlink" title="静态方法和实例方法"></a>静态方法和实例方法</h4><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式<code>对象.方法名</code> 的方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><hr><h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p><strong>重载</strong>：同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。（发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，仅仅只是返回值不同不算是重载，必须是参数不同，但重载的方法返回值和访问修饰符可以不同）</p><p><strong>重写</strong>：子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p><p><strong>方法的重写要遵循“两同两小一大”</strong></p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><hr><h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：<a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础概念与常识&quot;&gt;&lt;a href=&quot;#Java基础概念与常识&quot; class=&quot;headerlink&quot; title=&quot;Java基础概念与常识&quot;&gt;&lt;/a&gt;Java基础概念与常识&lt;/h2&gt;&lt;h3 id=&quot;Java语言的特点&quot;&gt;&lt;a href=&quot;#Java语言的特</summary>
      
    
    
    
    
    <category term="Java SE" scheme="https://linjz.netlify.app/tags/Java-SE/"/>
    
  </entry>
  
</feed>
